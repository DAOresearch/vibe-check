---
title: "Implementation Plan"
description: "End-to-end implementation plan for @dao/vibe-check"
---

> **✅ UPDATED:** This plan now reflects all finalized API decisions from `finalized-decisions.md`
>
> **Key changes:**
> - Added `vibeWorkflow` API (Section 2)
> - Updated `RunResult` interface with complete lazy-loading API (Section 18.1)
> - Replaced `ArtifactManager`/`MetricsTracker` with `ContextManager` (Section 6)
> - Updated matrix testing to reference `test.for` (Section 9)
> - Added hybrid disk bundle storage strategy (Section 6)

Below is a concrete, end‑to‑end implementation plan for @dao/vibe-check, turning your research into shippable code. It's organized as milestones with work items, APIs, skeletons, test strategy, and acceptance criteria. I highlight trade‑offs where they matter.

---

## 0) Scope & guardrails

### Goals
- DX-first test harness for agent workflows on top of Vitest with:
  - `vibeTest` (fixtures & custom context), matchers, reporters, matrix generation, and cost/todo/rubric evaluation.
  - Tight integration with Claude Agent SDK (streaming sessions, tools/MCP, slash-commands).
  - Minimal user surface; Vitest internals are hidden.

### Non-goals (initial cut)
- No GUI runner (we ship HTML reports only).
- No cross-process global rate limiter (recommend Vitest's maxWorkers and suite-level sequential control first).

### Compat constraints
- Vitest v3.x (fixtures, annotations, task metadata are stable there). Pin in peerDependencies and CI matrix.
- test.extend, typed context, per-test expect, scoped fixtures, and smart fixture init.
- Task metadata for passing data to reporters (experimental note; pin version).
- Annotations API (context.annotate) with reporter hook onTestAnnotate.
- Concurrency & concurrent snapshots require the context‑bound expect.
- Claude Agent SDK (TypeScript) with streaming query, custom MCP tools, permissions, slash commands, todo + usage/cost.

---

## 1) Repo & packaging (foundation)

### Deliverables
- Monorepo optional; single package is fine.
- `type: "module"`, dual output (ESM/CJS) via tsup.
- exports map:
  - `"."` main
  - `"./reporters"` reporters
  - `"./vitest"` (optional) setup helpers
- Strict TS, ESLint, Prettier, Changesets.

### Dependencies

```json
{
  "peerDependencies": {
    "vitest": "^3.2.0",
    "vite": "^5.0.0"
  },
  "dependencies": {
    "@anthropic-ai/claude-code": "^x.y.z",   // Claude Agent SDK
    "zod": "^3.23.0",
    "p-limit": "^5.0.0",
    "pathe": "^1.1.2",
    "fs-extra": "^11.2.0"
  },
  "devDependencies": {
    "tsup": "^8.0.0",
    "typescript": "^5.5.0",
    "@types/node": "^20.11.0",
    "vitest": "^3.2.0"
  }
}
```

### Structure

```
@dao/vibe-check/
├─ src/
│  ├─ index.ts
│  ├─ test/
│  │  ├─ vibeTest.ts
│  │  ├─ context.ts
│  │  └─ matchers.ts
│  ├─ runner/
│  │  └─ agentRunner.ts
│  ├─ judge/
│  │  ├─ rubric.ts
│  │  └─ llmJudge.ts
│  ├─ reporters/
│  │  ├─ html.ts
│  │  └─ cost.ts
│  ├─ matrix/defineTestSuite.ts
│  ├─ config/index.ts
│  ├─ artifacts/
│  │  ├─ ArtifactManager.ts
│  │  └─ snapshot.ts
│  ├─ metrics/MetricsTracker.ts
│  └─ utils/{tempfs, git, time, dataQuery}.ts
├─ reporters/index.ts
└─ vitest.config.ts (for this package's own tests)
```

### Acceptance
- Build emits ESM/CJS + .d.ts.
- Subpath imports resolve.
- Lint, typecheck, unit tests green.

---

## 2) vibeTest & vibeWorkflow - Dual API

### Overview

**Finalized Decision:** Two separate APIs with different semantics (see `finalized-decisions.md` Part 1.1)

- **`vibeTest`** - For evaluation/testing use cases (benchmarking, quality gates, matrix testing)
- **`vibeWorkflow`** - For automation/pipeline use cases (multi-stage, loops, production workflows)

### Work items

**1. Types & augmentation**

```typescript
// src/test/context.ts

/** Context for vibeTest - evaluation/testing */
export interface VibeTestContext {
  runAgent(opts: RunAgentOptions): Promise<RunResult>;
  judge(res: RunResult, opts: { rubric: Rubric; throwOnFail?: boolean }): Promise<JudgeResult>;
  expect: typeof import('vitest')['expect'];
  annotate(message: string, type?: string, attachment?: TestAttachment): Promise<void>;
  task: import('vitest').TestContext['task'];
}

/** Context for vibeWorkflow - automation/pipelines */
export interface WorkflowContext {
  /** Run one stage, returns RunResult and accumulates into workflow */
  stage(name: string, opts: RunAgentOptions): Promise<RunResult>;

  /** Access cumulative state across stages */
  files: {
    allChanged(): FileChange[];
    byStage(stage?: string): FileChange[];
  };
  tools: {
    all(): Array<{ stage: string; call: ToolCall }>;
  };
  timeline: {
    events(): AsyncIterable<{ stage: string; evt: TimelineEvent }>;
  };

  /** Loop helpers */
  until(
    predicate: (latest: RunResult) => boolean | Promise<boolean>,
    body: () => Promise<RunResult>,
    opts?: { maxIterations?: number }
  ): Promise<RunResult[]>;

  /** Default workspace & model overrides for this workflow */
  defaults: { workspace?: string; model?: string };
}

declare module 'vitest' {
  // augments global TestContext for hooks & generics consumers
  export interface TestContext extends VibeTestContext {}
}
```

**2. test.extend with fixtures (lazy init, teardown)**

```typescript
// src/test/vibeTest.ts
import { test as base } from 'vitest';
import { ContextManager } from '../runner/ContextManager';
import { createJudge } from '../judge/llmJudge';

export const vibeTest = base.extend<VibeTestContext>({
  runAgent: async ({ task }, use) => {
    const ctx = new ContextManager({
      testId: task.id,
      workspace: undefined,  // Uses default or override
      annotate: task.context?.annotate
    });

    await use(async (opts: RunAgentOptions) => {
      // Execute agent with SDK, capture hooks, finalize context
      const result = await ctx.runAgent(opts);

      // Store thin meta for reporters
      task.meta.metrics = result.metrics;
      task.meta.bundleDir = result.bundleDir;

      return result;
    });

    // Cleanup (if needed)
    await ctx.cleanup?.();
  },

  judge: async ({}, use) => {
    const j = createJudge();
    await use(j.evaluate.bind(j));
  },
});

// src/test/vibeWorkflow.ts
import { test as base } from 'vitest';
import { WorkflowRunner } from '../runner/WorkflowRunner';

export function vibeWorkflow(
  name: string,
  fn: (ctx: WorkflowContext) => Promise<void>,
  options?: {
    timeout?: number;
    defaults?: { workspace?: string; model?: string }
  }
): void {
  base(name, async ({ task }) => {
    const wf = new WorkflowRunner({
      testId: task.id,
      defaults: options?.defaults,
      annotate: task.context?.annotate
    });

    await fn(wf.context);

    // Store cumulative meta
    task.meta.metrics = wf.getCumulativeMetrics();
    task.meta.bundleDir = wf.bundleDir;
  }, options?.timeout);
}
```

- This leverages Vitest's fixture model, smart init, generics typing, and scoped values.
- **Key change:** Uses `ContextManager` instead of separate `ArtifactManager` + `MetricsTracker` (see finalized-decisions.md Part 2.2)

**3. Modifiers & concurrency**

- `test.extend` returns a fully-featured Test API (no manual forwarding).
- Docs/examples will emphasize context expect in concurrent/snapshots.

### Acceptance
- User can import `{ vibeTest }` from `'@dao/vibe-check'` and receive typed fixtures.
- Only used fixtures initialize per test.

---

## 3) Global hooks & isolation

### Work items
- Provide optional global setup via defineVibeConfig:
  - sensible timeouts (agent work is slower than unit tests),
  - test isolation defaults,
  - default reporters.

```typescript
// src/config/index.ts
import { defineConfig } from 'vitest/config';
import { VibeHtmlReporter } from '../reporters/html';
import { VibeCostReporter } from '../reporters/cost';

export function defineVibeConfig(user = {}) {
  return defineConfig({
    test: {
      // encourage context-bound expect for snapshots in concurrent tests
      snapshotFormat: { escapeString: false }, // follows Vitest v3 defaults
      maxWorkers: '50%', // sane default; overridable
      reporters: ['default', new VibeCostReporter(), new VibeHtmlReporter()],
      // users can still adjust poolOptions / sequence.concurrent
      ...user?.test,
    },
    ...user,
  });
}
```

- Users can also cap workers via maxWorkers/poolOptions if they hit API limits.

### Acceptance
- Config helper merges cleanly, respects user overrides.

---

## 4) Snapshot strategy

### Work items
- Encourage `({ expect }) => { expect(value).toMatchSnapshot(...) }` to minimize collision in concurrent runs.
- Document property matchers for dynamic fields (`expect.any(Number)`, etc.). Vitest snapshot guide aligns with Jest-style property matchers.

### Acceptance
- Example snapshots stable under concurrency and ignore volatile fields.

---

## 5) Custom matchers

### Work items
- Ship global setup file `src/test/matchers.ts` and auto-register in config (setupFiles) or in vibeTest bootstrap.
- Initial matchers:
  - `toPassRubric(rubric)`
  - `toStayUnderCost(maxUsd)`
  - `toCompleteAllTodos()`
  - `toUseOnlyTools(allowlist: string[])`
  - `toHaveNoErrorsInLogs()`

```typescript
// src/test/matchers.ts
import { expect } from 'vitest';

expect.extend({
  toStayUnderCost(received: RunResult, maxUsd: number) {
    const pass = (received.metrics?.totalCostUsd ?? 0) <= maxUsd;
    return {
      pass,
      message: () => `expected cost <= $${maxUsd}, got $${received.metrics?.totalCostUsd?.toFixed(2)}`,
    };
  },
  // ...others
});
```

- Type augmentation for Assertion as per Vitest docs.

### Acceptance
- Matchers available in any vibeTest without user boilerplate.

---

## 6) Agent runner & ContextManager

### Overview

**Architecture (from finalized-decisions.md Part 2):**
- **ContextManager** - Manages RunContext lifecycle (capture → process → inject)
- **AgentRunner** - Executes Claude SDK, captures hooks, returns RunResult
- **Storage** - Hybrid disk bundle (canonical) + thin task.meta (pointers)

### Work items

**1. ContextManager class**

Manages the complete lifecycle of execution context capture and finalization.

```typescript
// src/runner/ContextManager.ts
export class ContextManager {
  constructor(private opts: {
    testId: string;
    workspace?: string;
    annotate?: (m: string, t?: string, a?: any) => Promise<void>
  }) {}

  // Canonical on-disk "bundle" for this test
  public readonly bundleDir = path.join('.vibe-artifacts', sanitize(this.opts.testId));

  // In-memory light summary, persisted to summary.json in finalize()
  private summary: Summary = initSummary();

  // Writer handles (append-only)
  private evtWriter = createNDJSONWriter(path.join(this.bundleDir, 'events.ndjson'));
  private hookWriter = createNDJSONWriter(path.join(this.bundleDir, 'hooks.ndjson'));

  async onSDKEvent(evt: SDKEvent) {
    // called from runAgent's for-await loop
    await this.evtWriter.write(evt);
    accumulateMetrics(this.summary.metrics, evt);
    // stream DX breadcrumbs
    if (isTodoUpdate(evt)) await this.opts.annotate?.(`TODOs: ${briefTodos(evt)}`, 'todo');
    if (isTool(evt)) await this.opts.annotate?.(`Tool: ${toolLabel(evt)}`, 'tool');
  }

  async onHookPayload(json: unknown) {
    // invoked by tiny hook-runner (writes hook JSONL)
    await this.hookWriter.write(json);
  }

  async finalize(): Promise<RunResult> {
    // correlate hooks -> toolCalls, compute file changes, write summary.json
    const hooks = await readNDJSON(path.join(this.bundleDir, 'hooks.ndjson'));
    const { toolCalls, fileChanges } = correlateAndDiff(hooks, this.opts.workspace);
    this.summary.toolCalls = toolCalls.map(minimizeForSummary);
    this.summary.fileStats = statsFor(fileChanges);

    await fs.writeFile(
      path.join(this.bundleDir, 'summary.json'),
      JSON.stringify(this.summary, null, 2)
    );
    return makeLazyRunResult({
      bundleDir: this.bundleDir,
      summary: this.summary,
      annotate: this.opts.annotate
    });
  }
}
```

**2. AgentRunner integration**

Implement AgentRunner to:
  - Start streaming session (query), attach hooks, respect timeout/turn caps.
  - Track messages, tool uses, todos, usage/tokens/cost via ContextManager.
  - Accept allowed tools, MCP (in-process or external), system prompt preset + append.
  - Emit annotations for key events (tools, todo progress) to enrich reporters.

```typescript
// src/runner/agentRunner.ts
import { query } from '@anthropic-ai/claude-code';
import type { SDKUserMessage } from '@anthropic-ai/claude-code';
import { MetricsTracker } from '../metrics/MetricsTracker';
import { ArtifactManager } from '../artifacts/ArtifactManager';

export class AgentRunner {
  constructor(private readonly opts: {
    artifacts: ArtifactManager;
    metrics: MetricsTracker;
    testId: string;
  }) {}

  async run(input: RunInput, ctx?: { annotate?: (msg: string, type?: string) => Promise<void>, signal?: AbortSignal }): Promise<RunResult> {
    const data: StructuredRunData = initStructured();
    const controller = new AbortController();
    const signal = ctx?.signal ?? controller.signal;

    const options = this.makeOptions(input, { signal });
    const stream = query({ prompt: this.asPrompt(input), options }); // streaming async generator

    const started = performance.now();
    for await (const evt of stream) {
      this.capture(evt, data); // messages, tools, todos, usage, partials
      if (isTodoUpdate(evt)) await ctx?.annotate?.(`TODOs: ${formatTodos(evt)}`);
      if (isToolUse(evt))    await ctx?.annotate?.(`Tool: ${formatTool(evt)}`);
    }

    data.metrics.durationMs = performance.now() - started;
    this.opts.metrics.record(data.metrics);
    await this.opts.artifacts.flushForTest(this.opts.testId, data);

    return summarize(data);
  }

  // build session options: model, permissions, allowedTools, MCP servers, timeouts
  private makeOptions(input: RunInput, extra: { signal: AbortSignal }) {
    return {
      model: input.model ?? 'claude-3-5-sonnet-latest',
      permissionMode: 'bypassPermissions', // CI-friendly; configurable
      allowedTools: input.allowedTools,
      mcpServers: input.mcpServers,        // namespaced tool exposure
      maxTurns: input.maxTurns ?? 20,
      timeoutMs: input.timeoutMs ?? 300_000,
      systemPrompt: input.systemPrompt,    // preset + append if supplied
      signal: extra.signal,
    } satisfies AgentOptions;
  }

  async cleanup() {/* noop for now */}
}
```

- Slash commands: support passing `/something args` as the first user message; we document how users can pre-write Markdown commands into `.claude/commands/` and permit tools via frontmatter.
- Todos & usage/cost: record from SDK events/final result (authoritative total).

### Security & sandbox
- Run in a per-test temp dir; forbid paths outside.
- Encourage limiting tools via allowedTools and MCP allowlists.
- (Doc) recommend sequential for destructive flows.

### Acceptance
- `runAgent({ prompt: '/refactor', repo: ... })` returns RunResult with messages, tools, todos, `metrics.totalCostUsd`, `durationMs`, artifacts.

---

## 7) Reporters

### Work items
- **VibeCostReporter**: console summary (per-test and totals).
- **VibeHtmlReporter**: rich HTML with transcript, tools timeline, todos, artifacts, rubric verdicts, charts.

### Implementation hooks:
- `onTestAnnotate` to stream notable events; `onTestCaseResult` to aggregate; `onTestRunEnd` to write files.
- Read per-test metadata via `testCase.meta()`.

```typescript
// src/reporters/cost.ts
import { BaseReporter } from 'vitest/reporters';
import type { Reporter, TestCase } from 'vitest/node';

export class VibeCostReporter extends BaseReporter implements Reporter {
  private totals = { cost: 0, tokens: 0 };

  onTestCaseResult(tc: TestCase) {
    const m = tc.meta();
    if (typeof m?.metrics?.totalCostUsd === 'number') {
      this.totals.cost += m.metrics.totalCostUsd;
    }
  }
  onTestRunEnd() {
    this.log(`\n[vibe] total cost $${this.totals.cost.toFixed(2)}\n`);
    super.onTestRunEnd?.([], []);
  }
}
```

- Users enable reporters through our defineVibeConfig (instances allowed).

### Acceptance
- Cost totals printed; HTML file(s) generated with per-test drill downs.

---

## 8) Task metadata & annotations (DX sugar)

### Work items
- Expose helpers on context: `ctx.task.meta.maxCost`, tags, notes, etc.; extend TaskMeta typings via declaration merging.
- `context.annotate()` calls inside runAgent stream to reporters; we surface critical milestones (tool use, todo updates).

### Acceptance
- Reporter receives custom meta & annotations and reflects them in output.

---

## 9) Matrix generation

### Work items
- Provide `defineTestSuite({ matrix, test })` that expands to N vibeTest calls
- **Recommendation (from finalized-decisions.md Part 3.2):** Use `test.for` for better fixture integration
- Fallback: Use `test.each` or direct iteration for simpler cases

```typescript
// src/matrix/defineTestSuite.ts
import { describe } from 'vitest';
import { vibeTest } from './vibeTest';

// Recommended: Use test.for for better integration with TestContext
export function defineTestSuite<T extends Record<string, any[]>>(cfg: {
  matrix: T;
  name?: string;
  test: (combo: { [K in keyof T]: T[K][number] }) => void;
}) {
  const combos = cartesian(cfg.matrix);
  describe(cfg.name ?? 'matrix', () => {
    for (const c of combos) cfg.test(c as any);
  });
}

// Alternative using test.for (Vitest v3+)
// test.for([{ model: 'sonnet' }, { model: 'opus' }])(
//   'benchmark $model',
//   async ({ runAgent, model }) => { ... }
// )
```

**Why `test.for` is better:** Integrates with TestContext and fixtures, provides better type safety (see finalized-decisions.md Part 3.2)

### Acceptance
- Passing a 2×2×2 matrix yields 8 tests with readable names.

---

## 10) Judges & rubrics

### Work items
- Zod schema for rubrics; hybrid evaluation model:
  - Programmatic checks first; LLM judge for subjective criteria.
  - `judge(result, { rubric })` returns JudgeResult and optionally throws on fail for one‑liner convenience.
  - Persist rationale into artifacts + test meta.

### Acceptance
- A failing criterion fails the test (either via judge throwing or matcher).
- Reporter includes per-criterion scores & rationales.

---

## 11) Artifacts & data helpers

### Work items
- ArtifactManager to snapshot diffs, large logs to files, and cap in-memory payloads.
- DataQuery utils to query messages, tool uses, todos quickly.

### Acceptance
- Artifacts written to per-test folder; large outputs truncated in memory and linked in report.

---

## 12) vi utilities & internal tests

### Work items
- Our own tests use `vi.mock`, `vi.spyOn`, `vi.useFakeTimers`, etc. (document for users).
- Provide cookbook examples (fake timers for retry/backoff, stubbing external tools).

### Acceptance
- Example tests demonstrate mocking and timers without flakiness.

---

## 13) Concurrency control & CI tuning

### Work items
- Docs recommend:
  - `test.concurrent`/`describe.concurrent` where safe, `test.sequential` where needed.
  - Cap workers with maxWorkers / poolOptions in CI to avoid API throttling.
  - Optional `VIBE_MAX_CONCURRENT_SESSIONS` soft limiter (per‑worker via p-limit).

### Acceptance
- Running with parallel files passes; users can force sequential for heavy cases.

---

## 14) Public API & docs

### Exports

```typescript
// src/index.ts
export { vibeTest } from './test/vibeTest';
export { defineVibeConfig } from './config';
export { defineTestSuite } from './matrix/defineTestSuite';
export * from './judge/rubric';
export type { VibeTestContext, RunResult, AgentConfig } from './types';
```

### Docs content (README / docs site)
- Getting started (install, API key env, vitest config).
- Writing tests with vibeTest and context.
- Snapshots + property matchers (examples).
- Custom matchers reference.
- Judge/rubric reference with examples.
- Reporters (CLI + HTML) screenshots.
- Matrix generation cookbook.
- Concurrency and costs tips (workers, sequential).
- Security sandbox guidance.

### Acceptance
- Examples compile and run in CI; docs link to working code.

---

## 15) Testing strategy

### Levels
- **Unit**: matchers, data query, metrics, artifact paths.
- **Integration**: vibeTest fixtures lifecycle; reporter hooks; metadata & annotations round-trip.
- **E2E (live)**: gated by env (CLAUDE_API_KEY), small end‑to‑end specs hitting SDK (smoke + cost budget).
- **Determinism**: use snapshots with property matchers; timeouts via fake timers where possible.

---

## 16) Risk & mitigations (selected)
- **Vitest TaskMeta is "experimental"** → pin `vitest@^3.2.x` and add compat tests.
- **API rate limits** → document maxWorkers and provide soft per‑worker p-limit.
- **Dangerous tools** → default to restricted allowedTools; temp working dir + allowlists for MCP servers.
- **Large outputs / OOM** → artifact manager truncation + on-disk spillover.
- **Flaky snapshots** → property matchers + context‑bound expect in concurrent suites.

---

## 17) Milestones & acceptance

### M1 – Foundation
- Build, types, exports, config helper.
- **Done when** package builds and defineVibeConfig is consumable.

### M2 – Fixtures & matchers
- vibeTest with runAgent stub; custom matchers.
- **Done when** sample test compiles, runs locally.

### M3 – Agent runner (SDK integration)
- Streaming capture of messages/tools/todos/metrics; artifacts; annotations.
- **Done when** `runAgent('/help')` returns structured data and cost appears.

### M4 – Reporters
- Cost + HTML reporters with metadata/annotations and per‑test drill down.
- **Done when** reporters render costs, transcript, tools timeline, todos, artifacts.

### M5 – Judges & matrix
- Rubrics, hybrid judge, defineTestSuite.
- **Done when** rubric failing test fails, matrix expands correctly.

### M6 – Docs & examples
- README, examples repo (basic/advanced/matrix).
- **Done when** a user can copy‑paste and get a passing run.

---

## 18) Representative code skeletons

### 18.1 Types (selected)

**IMPORTANT:** See `finalized-decisions.md` Part 1.2 for the complete, authoritative RunResult interface.

```typescript
// src/types.ts

/** Complete RunResult interface with lazy loading (see finalized-decisions.md Part 1.2) */
export interface RunResult {
  /** Absolute path to the on-disk bundle (source of truth) */
  readonly bundleDir: string;

  /** High-level metrics (merged SDK usage + wall time) */
  readonly metrics: {
    totalTokens?: number;
    totalCostUsd?: number;
    durationMs?: number;
    toolCalls?: number;
    filesChanged?: number;
  };

  /** Conversation messages (assistant/user/tool), small, summarized */
  readonly messages: Array<{
    role: 'system' | 'user' | 'assistant' | 'tool';
    summary: string;              // first 120 chars or structured title
    ts: number;
    /** Load full content from bundle on demand */
    load(): Promise<unknown>;
  }>;

  /** Todos recorded by SDK stream, with status at end of run */
  readonly todos: Array<{
    text: string;
    status: 'pending' | 'in_progress' | 'completed'
  }>;

  /** Git state before/after if workspace is git-managed */
  readonly git: {
    before?: { head: string; dirty: boolean };
    after?: { head: string; dirty: boolean };
    changedCount: number;
    /** Raw `git diff --name-status` as parsed entries */
    diffSummary(): Promise<Array<{
      path: string;
      change: 'A' | 'M' | 'D' | 'R';
      oldPath?: string
    }>>;
  };

  /** File changes correlated from hooks + git; content loaded lazily */
  readonly files: {
    /** All changed files as structured objects */
    changed(): FileChange[];
    /** Fast lookup */
    get(path: string): FileChange | undefined;
    /** Glob filter */
    filter(glob: string | string[]): FileChange[];
    /** Counts and quick stats */
    stats(): {
      added: number;
      modified: number;
      deleted: number;
      renamed: number;
      total: number
    };
  };

  /** Tool calls correlated from PreToolUse/PostToolUse */
  readonly tools: {
    all(): ToolCall[];
    used(name: string): number;  // count
    findFirst(name: string): ToolCall | undefined;
  };

  /** Unified timeline (SDK + hooks); reporters iterate to render */
  readonly timeline: {
    events(): AsyncIterable<TimelineEvent | TimelineEvent[]>; // supports batching
  };

  /** Convenience: annotate from user tests if desired (forwarded) */
  annotate?(
    message: string,
    type?: string,
    attachment?: {
      path?: string;
      body?: string | Buffer;
      contentType?: string
    }
  ): Promise<void>;
}

/** One changed file with safe, lazy content access */
export interface FileChange {
  path: string;
  changeType: 'added' | 'modified' | 'deleted' | 'renamed';
  oldPath?: string;

  before?: {
    sha256: string;
    size: number;
    text(): Promise<string>;
    stream(): NodeJS.ReadableStream;
  };

  after?: {
    sha256: string;
    size: number;
    text(): Promise<string>;
    stream(): NodeJS.ReadableStream;
  };

  stats?: { added: number; deleted: number; chunks: number };
  patch(format?: 'unified' | 'json'): Promise<string | object>;
}

export interface ToolCall {
  name: string;
  input: unknown;
  output?: unknown;
  ok: boolean;
  cwd?: string;
  startedAt: number;
  endedAt?: number;
  durationMs?: number;
  raw?: { preHookOffset: number; postHookOffset?: number };
}

export type TimelineEvent =
  | { type: 'sdk-message'; role: 'assistant' | 'user' | 'tool'; ts: number; ref?: number }
  | { type: 'hook'; name: 'PreToolUse' | 'PostToolUse' | 'Notification' | 'Stop' | 'SubagentStop' | 'SessionStart' | 'SessionEnd'; ts: number; ref?: number }
  | { type: 'todo'; ts: number; items: Array<{ text: string; status: string }> };

export type RunAgentFn = (input: {
  prompt: string;
  model?: string;
  allowedTools?: string[];
  mcpServers?: Record<string, any>;
  timeoutMs?: number;
  maxTurns?: number;
  systemPrompt?: { preset?: string; append?: string };
  workspace?: string;  // Override default workspace
}) => Promise<RunResult>;

export type JudgeFn = (result: RunResult, opts: { rubric: Rubric; throwOnFail?: boolean }) => Promise<JudgeResult>;
```

### 18.2 Task meta augmentation

```typescript
// ambient.d.ts
import 'vitest';
declare module 'vitest' {
  interface TaskMeta {
    maxCost?: number;
    tags?: string[];
    metrics?: RunMetrics;
    artifactsDir?: string;
  }
}
```

### 18.3 HTML reporter outline

```typescript
// src/reporters/html.ts
import { BaseReporter } from 'vitest/reporters';
import type { Reporter, TestCase, TestModule } from 'vitest/node';
import { writeFile } from 'node:fs/promises';
export class VibeHtmlReporter extends BaseReporter implements Reporter {
  private cases: Array<{ id: string; name: string; meta: any; result: any }> = [];
  onTestCaseResult(tc: TestCase) {
    this.cases.push({ id: tc.id, name: tc.fullName, meta: tc.meta(), result: tc.result() });
  }
  async onTestRunEnd(mods: readonly TestModule[]) {
    const html = renderHtml(this.cases, mods.map(m => m.moduleId));
    await writeFile('./vibe-report.html', html, 'utf8');
    super.onTestRunEnd?.(mods as any, []);
  }
}
```

---

## 19) Trade‑offs (quick takes)

| Decision | Pros | Cons | Choice |
|----------|------|------|--------|
| test.extend vs custom runner | Native, typed, smart fixture init | Deepest customization limited by runner internals | Acceptable (runner API rarely needed) |
| Matrix via loop vs test.each | Full control & context typing | test.each is ergonomic but less flexible | Choose loop; allow test.each in docs for simple cases |
| LLM judge vs programmatic | Coverage of subjective criteria | Programmatic is fast and deterministic | Adopt hybrid with clear failure messages |
| Streaming annotations vs stdout logs | Integrate with reporter lifecycle | stdout is simple | Use both: minimal stdout, key events via annotate |
| Concurrency defaults | Faster by default | Can trigger rate limits | Default to moderate workers, document tuning |

---

## 20) Example: "happy path" test

```typescript
import { vibeTest } from '@dao/vibe-check';

vibeTest('refactor stays under budget and completes todos', async ({ runAgent, judge, task, expect }) => {
  task.meta.maxCost = 3.50; // reporter can flag if exceeded

  const result = await runAgent({
    prompt: '/refactor src/index.ts',
    allowedTools: ['Edit', 'Bash(git *)'],
    maxTurns: 12,
  });

  expect(result).toStayUnderCost(task.meta.maxCost!);
  expect(result).toCompleteAllTodos();

  // Snapshot structured summary (ignore volatile fields)
  expect(result).toMatchSnapshot({
    metrics: { totalCostUsd: expect.any(Number), durationMs: expect.any(Number) },
  });

  await judge(result, { rubric: qualityRubric, throwOnFail: true });
});
```

---

## 21) What the user gets by default
- Single import (`vibeTest`) with typed context fixtures and matchers.
- Concurrent test speed with safe snapshots (context expect).
- HTML report that explains what the agent did (tools/todos/transcript/cost/rubric).
- Minimal config (defineVibeConfig) and pinning guidance for task meta API.

---

## References used to ground the plan
- Vitest Test Context / fixtures, per-test expect, scoped values.
- Vitest Task Metadata (experimental; type merging, reporter access).
- Test Annotations (context.annotate) + reporter hook.
- Reporter lifecycle & extending BaseReporter.
- Concurrency API & note on per-test expect for snapshots.
- CLI/Config worker caps (maxWorkers, poolOptions).
- Custom matchers (expect.extend) & TS tips.
- Snapshot usage (property/asymmetric matchers rationale).
- Claude Agent SDK TS reference, streaming vs single mode, tools/MCP names, permissions, todos, cost metrics, slash commands.

---

If you want, I can convert this into issues (labels, assignees, acceptance) or scaffold the code skeletons and a working minimal example in a repo template.
