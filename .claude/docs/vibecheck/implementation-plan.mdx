---
title: "Implementation Plan"
description: "End-to-end implementation plan for @dao/vibe-check"
---

Below is a concrete, end‑to‑end implementation plan for @dao/vibe-check, turning your research into shippable code. It's organized as milestones with work items, APIs, skeletons, test strategy, and acceptance criteria. I highlight trade‑offs where they matter.

---

## 0) Scope & guardrails

### Goals
- DX-first test harness for agent workflows on top of Vitest with:
  - `vibeTest` (fixtures & custom context), matchers, reporters, matrix generation, and cost/todo/rubric evaluation.
  - Tight integration with Claude Agent SDK (streaming sessions, tools/MCP, slash-commands).
  - Minimal user surface; Vitest internals are hidden.

### Non-goals (initial cut)
- No GUI runner (we ship HTML reports only).
- No cross-process global rate limiter (recommend Vitest's maxWorkers and suite-level sequential control first).

### Compat constraints
- Vitest v3.x (fixtures, annotations, task metadata are stable there). Pin in peerDependencies and CI matrix.
- test.extend, typed context, per-test expect, scoped fixtures, and smart fixture init.
- Task metadata for passing data to reporters (experimental note; pin version).
- Annotations API (context.annotate) with reporter hook onTestAnnotate.
- Concurrency & concurrent snapshots require the context‑bound expect.
- Claude Agent SDK (TypeScript) with streaming query, custom MCP tools, permissions, slash commands, todo + usage/cost.

---

## 1) Repo & packaging (foundation)

### Deliverables
- Monorepo optional; single package is fine.
- `type: "module"`, dual output (ESM/CJS) via tsup.
- exports map:
  - `"."` main
  - `"./reporters"` reporters
  - `"./vitest"` (optional) setup helpers
- Strict TS, ESLint, Prettier, Changesets.

### Dependencies

```json
{
  "peerDependencies": {
    "vitest": "^3.2.0",
    "vite": "^5.0.0"
  },
  "dependencies": {
    "@anthropic-ai/claude-code": "^x.y.z",   // Claude Agent SDK
    "zod": "^3.23.0",
    "p-limit": "^5.0.0",
    "pathe": "^1.1.2",
    "fs-extra": "^11.2.0"
  },
  "devDependencies": {
    "tsup": "^8.0.0",
    "typescript": "^5.5.0",
    "@types/node": "^20.11.0",
    "vitest": "^3.2.0"
  }
}
```

### Structure

```
@dao/vibe-check/
├─ src/
│  ├─ index.ts
│  ├─ test/
│  │  ├─ vibeTest.ts
│  │  ├─ context.ts
│  │  └─ matchers.ts
│  ├─ runner/
│  │  └─ agentRunner.ts
│  ├─ judge/
│  │  ├─ rubric.ts
│  │  └─ llmJudge.ts
│  ├─ reporters/
│  │  ├─ html.ts
│  │  └─ cost.ts
│  ├─ matrix/defineTestSuite.ts
│  ├─ config/index.ts
│  ├─ artifacts/
│  │  ├─ ArtifactManager.ts
│  │  └─ snapshot.ts
│  ├─ metrics/MetricsTracker.ts
│  └─ utils/{tempfs, git, time, dataQuery}.ts
├─ reporters/index.ts
└─ vitest.config.ts (for this package's own tests)
```

### Acceptance
- Build emits ESM/CJS + .d.ts.
- Subpath imports resolve.
- Lint, typecheck, unit tests green.

---

## 2) vibeTest fixtures & context

### Work items

**1. Types & augmentation**

```typescript
// src/test/context.ts
export interface VibeTestContext {
  runAgent?: RunAgentFn;
  judge?: JudgeFn;
  artifacts?: ArtifactManager;
  metrics?: MetricsTracker;
}

declare module 'vitest' {
  // augments global TestContext for hooks & generics consumers
  export interface TestContext extends VibeTestContext {}
}
```

**2. test.extend with fixtures (lazy init, teardown)**

```typescript
// src/test/vibeTest.ts
import { test as base } from 'vitest';
import { AgentRunner } from '../runner/agentRunner';
import { ArtifactManager } from '../artifacts/ArtifactManager';
import { MetricsTracker } from '../metrics/MetricsTracker';
import { createJudge } from '../judge/llmJudge';

export const vibeTest = base.extend<{
  runAgent: RunAgentFn;
  judge: JudgeFn;
  artifacts: ArtifactManager;
  metrics: MetricsTracker;
}>({
  artifacts: async ({}, use) => {
    const mgr = new ArtifactManager();
    await use(mgr);
    await mgr.flush();
  },

  metrics: async ({}, use) => {
    const m = new MetricsTracker();
    await use(m);
  },

  runAgent: async ({ artifacts, metrics, task }, use) => {
    const runner = new AgentRunner({ artifacts, metrics, testId: task.id });
    await use(runner.run.bind(runner));
    await runner.cleanup();
  },

  judge: async ({}, use) => {
    const j = createJudge();
    await use(j.evaluate.bind(j));
  },
});
```

- This leverages Vitest's fixture model, smart init, generics typing, and scoped values.

**3. Modifiers & concurrency**

- `test.extend` returns a fully-featured Test API (no manual forwarding).
- Docs/examples will emphasize context expect in concurrent/snapshots.

### Acceptance
- User can import `{ vibeTest }` from `'@dao/vibe-check'` and receive typed fixtures.
- Only used fixtures initialize per test.

---

## 3) Global hooks & isolation

### Work items
- Provide optional global setup via defineVibeConfig:
  - sensible timeouts (agent work is slower than unit tests),
  - test isolation defaults,
  - default reporters.

```typescript
// src/config/index.ts
import { defineConfig } from 'vitest/config';
import { VibeHtmlReporter } from '../reporters/html';
import { VibeCostReporter } from '../reporters/cost';

export function defineVibeConfig(user = {}) {
  return defineConfig({
    test: {
      // encourage context-bound expect for snapshots in concurrent tests
      snapshotFormat: { escapeString: false }, // follows Vitest v3 defaults
      maxWorkers: '50%', // sane default; overridable
      reporters: ['default', new VibeCostReporter(), new VibeHtmlReporter()],
      // users can still adjust poolOptions / sequence.concurrent
      ...user?.test,
    },
    ...user,
  });
}
```

- Users can also cap workers via maxWorkers/poolOptions if they hit API limits.

### Acceptance
- Config helper merges cleanly, respects user overrides.

---

## 4) Snapshot strategy

### Work items
- Encourage `({ expect }) => { expect(value).toMatchSnapshot(...) }` to minimize collision in concurrent runs.
- Document property matchers for dynamic fields (`expect.any(Number)`, etc.). Vitest snapshot guide aligns with Jest-style property matchers.

### Acceptance
- Example snapshots stable under concurrency and ignore volatile fields.

---

## 5) Custom matchers

### Work items
- Ship global setup file `src/test/matchers.ts` and auto-register in config (setupFiles) or in vibeTest bootstrap.
- Initial matchers:
  - `toPassRubric(rubric)`
  - `toStayUnderCost(maxUsd)`
  - `toCompleteAllTodos()`
  - `toUseOnlyTools(allowlist: string[])`
  - `toHaveNoErrorsInLogs()`

```typescript
// src/test/matchers.ts
import { expect } from 'vitest';

expect.extend({
  toStayUnderCost(received: RunResult, maxUsd: number) {
    const pass = (received.metrics?.totalCostUsd ?? 0) <= maxUsd;
    return {
      pass,
      message: () => `expected cost <= $${maxUsd}, got $${received.metrics?.totalCostUsd?.toFixed(2)}`,
    };
  },
  // ...others
});
```

- Type augmentation for Assertion as per Vitest docs.

### Acceptance
- Matchers available in any vibeTest without user boilerplate.

---

## 6) Agent runner (Claude SDK)

### Work items
- Implement AgentRunner to:
  - Start streaming session (query), attach hooks, respect timeout/turn caps.
  - Track messages, tool uses, todos, usage/tokens/cost, artifacts.
  - Accept allowed tools, MCP (in-process or external), system prompt preset + append.
  - Emit annotations for key events (tools, todo progress) to enrich reporters.

```typescript
// src/runner/agentRunner.ts
import { query } from '@anthropic-ai/claude-code';
import type { SDKUserMessage } from '@anthropic-ai/claude-code';
import { MetricsTracker } from '../metrics/MetricsTracker';
import { ArtifactManager } from '../artifacts/ArtifactManager';

export class AgentRunner {
  constructor(private readonly opts: {
    artifacts: ArtifactManager;
    metrics: MetricsTracker;
    testId: string;
  }) {}

  async run(input: RunInput, ctx?: { annotate?: (msg: string, type?: string) => Promise<void>, signal?: AbortSignal }): Promise<RunResult> {
    const data: StructuredRunData = initStructured();
    const controller = new AbortController();
    const signal = ctx?.signal ?? controller.signal;

    const options = this.makeOptions(input, { signal });
    const stream = query({ prompt: this.asPrompt(input), options }); // streaming async generator

    const started = performance.now();
    for await (const evt of stream) {
      this.capture(evt, data); // messages, tools, todos, usage, partials
      if (isTodoUpdate(evt)) await ctx?.annotate?.(`TODOs: ${formatTodos(evt)}`);
      if (isToolUse(evt))    await ctx?.annotate?.(`Tool: ${formatTool(evt)}`);
    }

    data.metrics.durationMs = performance.now() - started;
    this.opts.metrics.record(data.metrics);
    await this.opts.artifacts.flushForTest(this.opts.testId, data);

    return summarize(data);
  }

  // build session options: model, permissions, allowedTools, MCP servers, timeouts
  private makeOptions(input: RunInput, extra: { signal: AbortSignal }) {
    return {
      model: input.model ?? 'claude-3-5-sonnet-latest',
      permissionMode: 'bypassPermissions', // CI-friendly; configurable
      allowedTools: input.allowedTools,
      mcpServers: input.mcpServers,        // namespaced tool exposure
      maxTurns: input.maxTurns ?? 20,
      timeoutMs: input.timeoutMs ?? 300_000,
      systemPrompt: input.systemPrompt,    // preset + append if supplied
      signal: extra.signal,
    } satisfies AgentOptions;
  }

  async cleanup() {/* noop for now */}
}
```

- Slash commands: support passing `/something args` as the first user message; we document how users can pre-write Markdown commands into `.claude/commands/` and permit tools via frontmatter.
- Todos & usage/cost: record from SDK events/final result (authoritative total).

### Security & sandbox
- Run in a per-test temp dir; forbid paths outside.
- Encourage limiting tools via allowedTools and MCP allowlists.
- (Doc) recommend sequential for destructive flows.

### Acceptance
- `runAgent({ prompt: '/refactor', repo: ... })` returns RunResult with messages, tools, todos, `metrics.totalCostUsd`, `durationMs`, artifacts.

---

## 7) Reporters

### Work items
- **VibeCostReporter**: console summary (per-test and totals).
- **VibeHtmlReporter**: rich HTML with transcript, tools timeline, todos, artifacts, rubric verdicts, charts.

### Implementation hooks:
- `onTestAnnotate` to stream notable events; `onTestCaseResult` to aggregate; `onTestRunEnd` to write files.
- Read per-test metadata via `testCase.meta()`.

```typescript
// src/reporters/cost.ts
import { BaseReporter } from 'vitest/reporters';
import type { Reporter, TestCase } from 'vitest/node';

export class VibeCostReporter extends BaseReporter implements Reporter {
  private totals = { cost: 0, tokens: 0 };

  onTestCaseResult(tc: TestCase) {
    const m = tc.meta();
    if (typeof m?.metrics?.totalCostUsd === 'number') {
      this.totals.cost += m.metrics.totalCostUsd;
    }
  }
  onTestRunEnd() {
    this.log(`\n[vibe] total cost $${this.totals.cost.toFixed(2)}\n`);
    super.onTestRunEnd?.([], []);
  }
}
```

- Users enable reporters through our defineVibeConfig (instances allowed).

### Acceptance
- Cost totals printed; HTML file(s) generated with per-test drill downs.

---

## 8) Task metadata & annotations (DX sugar)

### Work items
- Expose helpers on context: `ctx.task.meta.maxCost`, tags, notes, etc.; extend TaskMeta typings via declaration merging.
- `context.annotate()` calls inside runAgent stream to reporters; we surface critical milestones (tool use, todo updates).

### Acceptance
- Reporter receives custom meta & annotations and reflects them in output.

---

## 9) Matrix generation

### Work items
- Provide `defineTestSuite({ matrix, test })` that expands to N vibeTest calls (no reliance on a hypothetical test.for; use test.each internally or a plain loop).
- Note: Vitest v3 docs don't have test.for; use test.each or direct iteration.

```typescript
// src/matrix/defineTestSuite.ts
import { describe } from 'vitest';
import { vibeTest } from './vibeTest';

export function defineTestSuite<T extends Record<string, any[]>>(cfg: {
  matrix: T;
  name?: string;
  test: (combo: { [K in keyof T]: T[K][number] }) => void;
}) {
  const combos = cartesian(cfg.matrix);
  describe(cfg.name ?? 'matrix', () => {
    for (const c of combos) cfg.test(c as any);
  });
}
```

### Acceptance
- Passing a 2×2×2 matrix yields 8 tests with readable names.

---

## 10) Judges & rubrics

### Work items
- Zod schema for rubrics; hybrid evaluation model:
  - Programmatic checks first; LLM judge for subjective criteria.
  - `judge(result, { rubric })` returns JudgeResult and optionally throws on fail for one‑liner convenience.
  - Persist rationale into artifacts + test meta.

### Acceptance
- A failing criterion fails the test (either via judge throwing or matcher).
- Reporter includes per-criterion scores & rationales.

---

## 11) Artifacts & data helpers

### Work items
- ArtifactManager to snapshot diffs, large logs to files, and cap in-memory payloads.
- DataQuery utils to query messages, tool uses, todos quickly.

### Acceptance
- Artifacts written to per-test folder; large outputs truncated in memory and linked in report.

---

## 12) vi utilities & internal tests

### Work items
- Our own tests use `vi.mock`, `vi.spyOn`, `vi.useFakeTimers`, etc. (document for users).
- Provide cookbook examples (fake timers for retry/backoff, stubbing external tools).

### Acceptance
- Example tests demonstrate mocking and timers without flakiness.

---

## 13) Concurrency control & CI tuning

### Work items
- Docs recommend:
  - `test.concurrent`/`describe.concurrent` where safe, `test.sequential` where needed.
  - Cap workers with maxWorkers / poolOptions in CI to avoid API throttling.
  - Optional `VIBE_MAX_CONCURRENT_SESSIONS` soft limiter (per‑worker via p-limit).

### Acceptance
- Running with parallel files passes; users can force sequential for heavy cases.

---

## 14) Public API & docs

### Exports

```typescript
// src/index.ts
export { vibeTest } from './test/vibeTest';
export { defineVibeConfig } from './config';
export { defineTestSuite } from './matrix/defineTestSuite';
export * from './judge/rubric';
export type { VibeTestContext, RunResult, AgentConfig } from './types';
```

### Docs content (README / docs site)
- Getting started (install, API key env, vitest config).
- Writing tests with vibeTest and context.
- Snapshots + property matchers (examples).
- Custom matchers reference.
- Judge/rubric reference with examples.
- Reporters (CLI + HTML) screenshots.
- Matrix generation cookbook.
- Concurrency and costs tips (workers, sequential).
- Security sandbox guidance.

### Acceptance
- Examples compile and run in CI; docs link to working code.

---

## 15) Testing strategy

### Levels
- **Unit**: matchers, data query, metrics, artifact paths.
- **Integration**: vibeTest fixtures lifecycle; reporter hooks; metadata & annotations round-trip.
- **E2E (live)**: gated by env (CLAUDE_API_KEY), small end‑to‑end specs hitting SDK (smoke + cost budget).
- **Determinism**: use snapshots with property matchers; timeouts via fake timers where possible.

---

## 16) Risk & mitigations (selected)
- **Vitest TaskMeta is "experimental"** → pin `vitest@^3.2.x` and add compat tests.
- **API rate limits** → document maxWorkers and provide soft per‑worker p-limit.
- **Dangerous tools** → default to restricted allowedTools; temp working dir + allowlists for MCP servers.
- **Large outputs / OOM** → artifact manager truncation + on-disk spillover.
- **Flaky snapshots** → property matchers + context‑bound expect in concurrent suites.

---

## 17) Milestones & acceptance

### M1 – Foundation
- Build, types, exports, config helper.
- **Done when** package builds and defineVibeConfig is consumable.

### M2 – Fixtures & matchers
- vibeTest with runAgent stub; custom matchers.
- **Done when** sample test compiles, runs locally.

### M3 – Agent runner (SDK integration)
- Streaming capture of messages/tools/todos/metrics; artifacts; annotations.
- **Done when** `runAgent('/help')` returns structured data and cost appears.

### M4 – Reporters
- Cost + HTML reporters with metadata/annotations and per‑test drill down.
- **Done when** reporters render costs, transcript, tools timeline, todos, artifacts.

### M5 – Judges & matrix
- Rubrics, hybrid judge, defineTestSuite.
- **Done when** rubric failing test fails, matrix expands correctly.

### M6 – Docs & examples
- README, examples repo (basic/advanced/matrix).
- **Done when** a user can copy‑paste and get a passing run.

---

## 18) Representative code skeletons

### 18.1 Types (selected)

```typescript
// src/types.ts
export interface RunMetrics {
  totalTokens?: number;
  totalCostUsd?: number;
  durationMs?: number;
}
export interface ToolCallRecord {
  name: string; input: unknown; output?: unknown; ok: boolean; startedAt: number; endedAt?: number;
}
export interface StructuredRunData {
  messages: AgentMessage[];
  toolCalls: ToolCallRecord[];
  todos: { text: string; status: 'pending'|'in_progress'|'completed' }[];
  metrics: RunMetrics;
  artifacts: string[]; // file paths
}
export interface RunResult extends StructuredRunData {}

export type RunAgentFn = (input: {
  prompt: string; model?: string; allowedTools?: string[]; mcpServers?: Record<string, any>;
  timeoutMs?: number; maxTurns?: number; systemPrompt?: { preset?: string; append?: string };
}) => Promise<RunResult>;

export type JudgeFn = (result: RunResult, opts: { rubric: Rubric; throwOnFail?: boolean }) => Promise<JudgeResult>;
```

### 18.2 Task meta augmentation

```typescript
// ambient.d.ts
import 'vitest';
declare module 'vitest' {
  interface TaskMeta {
    maxCost?: number;
    tags?: string[];
    metrics?: RunMetrics;
    artifactsDir?: string;
  }
}
```

### 18.3 HTML reporter outline

```typescript
// src/reporters/html.ts
import { BaseReporter } from 'vitest/reporters';
import type { Reporter, TestCase, TestModule } from 'vitest/node';
import { writeFile } from 'node:fs/promises';
export class VibeHtmlReporter extends BaseReporter implements Reporter {
  private cases: Array<{ id: string; name: string; meta: any; result: any }> = [];
  onTestCaseResult(tc: TestCase) {
    this.cases.push({ id: tc.id, name: tc.fullName, meta: tc.meta(), result: tc.result() });
  }
  async onTestRunEnd(mods: readonly TestModule[]) {
    const html = renderHtml(this.cases, mods.map(m => m.moduleId));
    await writeFile('./vibe-report.html', html, 'utf8');
    super.onTestRunEnd?.(mods as any, []);
  }
}
```

---

## 19) Trade‑offs (quick takes)

| Decision | Pros | Cons | Choice |
|----------|------|------|--------|
| test.extend vs custom runner | Native, typed, smart fixture init | Deepest customization limited by runner internals | Acceptable (runner API rarely needed) |
| Matrix via loop vs test.each | Full control & context typing | test.each is ergonomic but less flexible | Choose loop; allow test.each in docs for simple cases |
| LLM judge vs programmatic | Coverage of subjective criteria | Programmatic is fast and deterministic | Adopt hybrid with clear failure messages |
| Streaming annotations vs stdout logs | Integrate with reporter lifecycle | stdout is simple | Use both: minimal stdout, key events via annotate |
| Concurrency defaults | Faster by default | Can trigger rate limits | Default to moderate workers, document tuning |

---

## 20) Example: "happy path" test

```typescript
import { vibeTest } from '@dao/vibe-check';

vibeTest('refactor stays under budget and completes todos', async ({ runAgent, judge, task, expect }) => {
  task.meta.maxCost = 3.50; // reporter can flag if exceeded

  const result = await runAgent({
    prompt: '/refactor src/index.ts',
    allowedTools: ['Edit', 'Bash(git *)'],
    maxTurns: 12,
  });

  expect(result).toStayUnderCost(task.meta.maxCost!);
  expect(result).toCompleteAllTodos();

  // Snapshot structured summary (ignore volatile fields)
  expect(result).toMatchSnapshot({
    metrics: { totalCostUsd: expect.any(Number), durationMs: expect.any(Number) },
  });

  await judge(result, { rubric: qualityRubric, throwOnFail: true });
});
```

---

## 21) What the user gets by default
- Single import (`vibeTest`) with typed context fixtures and matchers.
- Concurrent test speed with safe snapshots (context expect).
- HTML report that explains what the agent did (tools/todos/transcript/cost/rubric).
- Minimal config (defineVibeConfig) and pinning guidance for task meta API.

---

## References used to ground the plan
- Vitest Test Context / fixtures, per-test expect, scoped values.
- Vitest Task Metadata (experimental; type merging, reporter access).
- Test Annotations (context.annotate) + reporter hook.
- Reporter lifecycle & extending BaseReporter.
- Concurrency API & note on per-test expect for snapshots.
- CLI/Config worker caps (maxWorkers, poolOptions).
- Custom matchers (expect.extend) & TS tips.
- Snapshot usage (property/asymmetric matchers rationale).
- Claude Agent SDK TS reference, streaming vs single mode, tools/MCP names, permissions, todos, cost metrics, slash commands.

---

If you want, I can convert this into issues (labels, assignees, acceptance) or scaffold the code skeletons and a working minimal example in a repo template.
