---
title: "Code Skeletons"
description: "TypeScript code skeletons for @dao/vibe-check"
---

Below are TypeScript code skeletons for @dao/vibe-check. Copy into a fresh repo and fill the TODOs.

---

## File tree

```
@dao/vibe-check/
├─ package.json
├─ tsconfig.json
├─ vitest.config.ts
├─ ambient.d.ts
├─ src/
│  ├─ index.ts
│  ├─ types.ts
│  ├─ config/index.ts
│  ├─ test/
│  │  ├─ context.ts
│  │  ├─ vibeTest.ts
│  │  └─ matchers.ts
│  ├─ runner/
│  │  ├─ agentRunner.ts
│  │  └─ sdk-types.ts
│  ├─ judge/
│  │  ├─ rubric.ts
│  │  └─ llmJudge.ts
│  ├─ reporters/
│  │  ├─ cost.ts
│  │  └─ html.ts
│  ├─ matrix/defineTestSuite.ts
│  ├─ artifacts/ArtifactManager.ts
│  ├─ metrics/MetricsTracker.ts
│  └─ utils/
│     ├─ dataQuery.ts
│     ├─ tempfs.ts
│     ├─ time.ts
│     └─ git.ts
└─ examples/
   └─ basic.test.ts
```

---

## Root

### package.json

```json
{
  "name": "@dao/vibe-check",
  "version": "0.1.0",
  "private": false,
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    },
    "./reporters": {
      "types": "./dist/reporters/index.d.ts",
      "import": "./dist/reporters/index.js",
      "require": "./dist/reporters/index.cjs"
    }
  },
  "files": ["dist"],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "test": "vitest run",
    "test:ui": "vitest"
  },
  "peerDependencies": {
    "vitest": "^3.2.0",
    "vite": "^5.0.0"
  },
  "dependencies": {
    "zod": "^3.23.0",
    "fs-extra": "^11.2.0",
    "pathe": "^1.1.2",
    "p-limit": "^5.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "tsup": "^8.0.0",
    "typescript": "^5.5.0",
    "vitest": "^3.2.0"
  }
}
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "types": ["vitest"]
  },
  "include": ["src", "ambient.d.ts", "examples", "vitest.config.ts"]
}
```

### vitest.config.ts

```typescript
import { defineVibeConfig } from './src/config';

export default defineVibeConfig({
  test: {
    include: ['examples/**/*.test.ts'],
    // tweak workers/timeouts as needed
  },
});
```

### ambient.d.ts

```typescript
// Vitest task meta augmentation + custom matchers
import 'vitest';

declare module 'vitest' {
  interface TaskMeta {
    maxCost?: number;
    tags?: string[];
    metrics?: import('./src/types').RunMetrics;
    artifactsDir?: string;
  }

  interface Assertion<T = any> {
    toStayUnderCost(maxUsd: number): T;
    toCompleteAllTodos(): T;
    toPassRubric(rubric: import('./src/judge/rubric').Rubric): T;
    toUseOnlyTools(names: string[]): T;
    toHaveNoErrorsInLogs(): T;
  }
}
```

---

## Public API

### src/index.ts

```typescript
export { vibeTest } from './test/vibeTest';
export { defineVibeConfig } from './config';
export { defineTestSuite } from './matrix/defineTestSuite';
export { VibeHtmlReporter } from './reporters/html';
export { VibeCostReporter } from './reporters/cost';

export * from './types';
export * from './judge/rubric';
```

### src/types.ts

```typescript
export interface RunMetrics {
  totalTokens?: number;
  totalCostUsd?: number;
  durationMs?: number;
}

export interface ToolCallRecord {
  name: string;
  input: unknown;
  output?: unknown;
  ok: boolean;
  startedAt: number;
  endedAt?: number;
}

export interface AgentMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: unknown;
  usage?: { inputTokens?: number; outputTokens?: number };
  ts: number;
}

export interface TodoItem {
  text: string;
  status: 'pending' | 'in_progress' | 'completed';
}

export interface StructuredRunData {
  messages: AgentMessage[];
  toolCalls: ToolCallRecord[];
  todos: TodoItem[];
  metrics: RunMetrics;
  artifacts: string[]; // file paths
}

export interface RunResult extends StructuredRunData {}

export type RunAgentInput = {
  prompt: string;                 // can include slash commands
  model?: string;
  allowedTools?: string[];
  mcpServers?: Record<string, unknown>;
  timeoutMs?: number;
  maxTurns?: number;
  systemPrompt?: { preset?: string; append?: string };
  repoPath?: string;              // working directory (temp by default)
};

export type RunAgentFn = (input: RunAgentInput) => Promise<RunResult>;

export interface JudgeResult {
  passed: boolean;
  score?: number; // 0..1
  details?: unknown;
}

export type JudgeFn = (result: RunResult, opts: { rubric: import('./judge/rubric').Rubric; throwOnFail?: boolean }) => Promise<JudgeResult>;
```

---

## Config helper

### src/config/index.ts

```typescript
import { defineConfig } from 'vitest/config';
import { VibeHtmlReporter } from '../reporters/html';
import { VibeCostReporter } from '../reporters/cost';

export function defineVibeConfig(user: any = {}) {
  return defineConfig({
    test: {
      maxWorkers: '50%',
      testTimeout: 180_000,
      hookTimeout: 60_000,
      reporters: ['default', new VibeCostReporter(), new VibeHtmlReporter()],
      setupFiles: [new URL('../test/matchers.ts', import.meta.url).pathname],
      ...user?.test,
    },
    ...user,
  });
}

export default defineVibeConfig;
```

---

## Test context & fixtures

### src/test/context.ts

```typescript
import type { ArtifactManager } from '../artifacts/ArtifactManager';
import type { MetricsTracker } from '../metrics/MetricsTracker';
import type { JudgeFn, RunAgentFn } from '../types';

export interface VibeTestContext {
  runAgent?: RunAgentFn;
  judge?: JudgeFn;
  artifacts?: ArtifactManager;
  metrics?: MetricsTracker;
}

declare module 'vitest' {
  export interface TestContext extends VibeTestContext {}
}
```

### src/test/vibeTest.ts

```typescript
import { test as base } from 'vitest';
import type { VibeTestContext } from './context';
import { ArtifactManager } from '../artifacts/ArtifactManager';
import { MetricsTracker } from '../metrics/MetricsTracker';
import { AgentRunner } from '../runner/agentRunner';
import { createJudge } from '../judge/llmJudge';

export const vibeTest = (base.extend as any)<VibeTestContext>({
  artifacts: async ({}, use) => {
    const mgr = new ArtifactManager();
    await use(mgr);
    await mgr.flush();
  },

  metrics: async ({}, use) => {
    const tracker = new MetricsTracker();
    await use(tracker);
  },

  runAgent: async ({ artifacts, metrics, task }, use) => {
    const runner = new AgentRunner({
      testId: task.id,
      artifacts: artifacts!,
      metrics: metrics!,
    });
    await use(runner.run.bind(runner));
    await runner.cleanup();
  },

  judge: async ({}, use) => {
    const j = createJudge();
    await use(j.evaluate.bind(j));
  },
});

export type { VibeTestContext };
```

### src/test/matchers.ts

```typescript
import { expect } from 'vitest';
import type { RunResult } from '../types';

expect.extend({
  toStayUnderCost(received: RunResult, maxUsd: number) {
    const cost = received.metrics?.totalCostUsd ?? 0;
    const pass = cost <= maxUsd;
    return {
      pass,
      message: () => `expected cost <= $${maxUsd.toFixed(2)}, got $${cost.toFixed(2)}`,
    };
  },

  toCompleteAllTodos(received: RunResult) {
    const undone = (received.todos ?? []).filter(t => t.status !== 'completed');
    const pass = undone.length === 0;
    return {
      pass,
      message: () => `expected all todos completed, remaining: ${undone.map(t => t.text).join(', ')}`,
    };
  },

  toPassRubric(received: RunResult, rubric: any) {
    // NOTE: real impl should reuse judge(); skeleton returns pass-through
    const pass = Boolean(rubric);
    return {
      pass,
      message: () => `expected to pass rubric`,
    };
  },

  toUseOnlyTools(received: RunResult, names: string[]) {
    const used = new Set((received.toolCalls ?? []).map(t => t.name));
    const invalid = [...used].filter(n => !names.includes(n));
    const pass = invalid.length === 0;
    return {
      pass,
      message: () => `unexpected tools: ${invalid.join(', ')}`,
    };
  },

  toHaveNoErrorsInLogs(received: RunResult) {
    const msgs = received.messages ?? [];
    const found = msgs.some(m => typeof m.content === 'string' && /error|exception|stack/i.test(m.content));
    return {
      pass: !found,
      message: () => `found error-like strings in transcript`,
    };
  },
});
```

---

## Runner

### src/runner/sdk-types.ts

```typescript
// Placeholder types to decouple from the real SDK; replace with actual imports later.

export interface AgentOptions {
  model: string;
  permissionMode?: 'bypassPermissions' | 'ask';
  allowedTools?: string[];
  mcpServers?: Record<string, unknown>;
  maxTurns?: number;
  timeoutMs?: number;
  systemPrompt?: { preset?: string; append?: string };
  signal?: AbortSignal;
  cwd?: string;
}

export type SDKEvent =
  | { type: 'assistant'; content: string; usage?: { inputTokens?: number; outputTokens?: number } }
  | { type: 'tool_use'; name: string; input: unknown; output?: unknown }
  | { type: 'todo'; items: { text: string; status: 'pending' | 'in_progress' | 'completed' }[] }
  | { type: 'end'; totalCostUsd?: number };

export interface SDKStream extends AsyncIterable<SDKEvent> {}

export interface SDKClient {
  query(prompt: string, options: AgentOptions): SDKStream;
  close(): Promise<void>;
}
```

### src/runner/agentRunner.ts

```typescript
import { RunResult, StructuredRunData, RunAgentInput } from '../types';
import { ArtifactManager } from '../artifacts/ArtifactManager';
import { MetricsTracker } from '../metrics/MetricsTracker';
import { createTempWorkspace } from '../utils/tempfs';
import { nowMs } from '../utils/time';
import type { SDKClient, SDKEvent, AgentOptions } from './sdk-types';

// TODO: wire to real Claude Agent SDK client
function createSDKClient(): SDKClient {
  return {
    query(_prompt: string, _options: AgentOptions) {
      async function* gen() {
        // yield demo events
        yield { type: 'assistant', content: 'Starting...', usage: { inputTokens: 10, outputTokens: 20 } } as SDKEvent;
        yield { type: 'todo', items: [{ text: 'Refactor', status: 'completed' }] } as SDKEvent;
        yield { type: 'tool_use', name: 'Edit', input: { file: 'src/a.ts' }, output: { ok: true } } as SDKEvent;
        yield { type: 'end', totalCostUsd: 0.002 } as SDKEvent;
      }
      return { [Symbol.asyncIterator]: gen } as any;
    },
    async close() {},
  };
}

export class AgentRunner {
  private client: SDKClient;
  private workspace?: { dir: string; cleanup: () => Promise<void> };

  constructor(
    private readonly deps: {
      testId: string;
      artifacts: ArtifactManager;
      metrics: MetricsTracker;
    },
  ) {
    this.client = createSDKClient();
  }

  async run(input: RunAgentInput): Promise<RunResult> {
    const ws = await createTempWorkspace({ prefix: `vibe-${this.deps.testId}` });
    this.workspace = ws;

    const data: StructuredRunData = {
      messages: [],
      toolCalls: [],
      todos: [],
      metrics: {},
      artifacts: [],
    };

    const started = nowMs();

    const options: AgentOptions = {
      model: input.model ?? 'claude-3-5-sonnet-latest',
      permissionMode: 'bypassPermissions',
      allowedTools: input.allowedTools,
      mcpServers: input.mcpServers,
      maxTurns: input.maxTurns ?? 20,
      timeoutMs: input.timeoutMs ?? 300_000,
      systemPrompt: input.systemPrompt,
      cwd: input.repoPath ?? ws.dir,
    };

    for await (const evt of this.client.query(input.prompt, options)) {
      this.capture(evt, data);
      // TODO: context.annotate hooks if we pass test context in future
    }

    data.metrics.durationMs = nowMs() - started;
    this.deps.metrics.record(data.metrics);
    await this.deps.artifacts.flushForTest(this.deps.testId, data);

    return data;
  }

  private capture(evt: SDKEvent, data: StructuredRunData) {
    const ts = nowMs();

    if (evt.type === 'assistant') {
      data.messages.push({ role: 'assistant', content: evt.content, usage: evt.usage, ts });
      if (evt.usage) {
        const inT = evt.usage.inputTokens ?? 0;
        const outT = evt.usage.outputTokens ?? 0;
        data.metrics.totalTokens = (data.metrics.totalTokens ?? 0) + inT + outT;
      }
    }

    if (evt.type === 'tool_use') {
      data.toolCalls.push({
        name: evt.name,
        input: evt.input,
        output: evt.output,
        ok: true,
        startedAt: ts,
        endedAt: ts,
      });
    }

    if (evt.type === 'todo') {
      data.todos = evt.items.map(i => ({ text: i.text, status: i.status }));
    }

    if (evt.type === 'end') {
      if (typeof evt.totalCostUsd === 'number') {
        data.metrics.totalCostUsd = evt.totalCostUsd;
      }
    }
  }

  async cleanup() {
    await this.client.close();
    if (this.workspace) await this.workspace.cleanup();
  }
}
```

---

## Judges & rubrics

### src/judge/rubric.ts

```typescript
import { z } from 'zod';

export const CriterionSchema = z.object({
  id: z.string(),
  description: z.string(),
  weight: z.number().min(0).max(1),
  required: z.boolean().default(false),
  kind: z.enum(['programmatic', 'llm']).default('llm'),
});

export const RubricSchema = z.object({
  criteria: z.array(CriterionSchema).min(1),
  passingScore: z.number().min(0).max(1).default(0.7),
  evaluationMethod: z.enum(['llm', 'programmatic', 'hybrid']).default('hybrid'),
});

export type Rubric = z.infer<typeof RubricSchema>;
export type Criterion = z.infer<typeof CriterionSchema>;
```

### src/judge/llmJudge.ts

```typescript
import type { RunResult, JudgeResult } from '../types';
import type { Rubric } from './rubric';

export function createJudge() {
  return new LLMJudge();
}

export class LLMJudge {
  // TODO: inject LLM client via constructor options
  async evaluate(run: RunResult, opts: { rubric: Rubric; throwOnFail?: boolean }): Promise<JudgeResult> {
    // TODO: run programmatic checks, then LLM scoring
    const passed = true; // placeholder
    const res: JudgeResult = { passed, score: 1 };
    if (!passed && opts.throwOnFail) {
      throw Object.assign(new Error('Rubric failed'), { judge: res });
    }
    return res;
  }
}
```

---

## Reporters

### src/reporters/cost.ts

```typescript
import { BaseReporter } from 'vitest/reporters';
import type { Reporter, TestCase } from 'vitest/node';

export class VibeCostReporter extends BaseReporter implements Reporter {
  private totals = { cost: 0, tests: 0 };

  onTestCaseResult(tc: TestCase) {
    this.totals.tests++;
    const m = tc.meta?.();
    const cost = Number(m?.metrics?.totalCostUsd ?? 0);
    this.totals.cost += cost;
  }

  onTestRunEnd() {
    this.log(`\n[vibe] Total tests: ${this.totals.tests}, total cost: $${this.totals.cost.toFixed(4)}\n`);
  }
}
```

### src/reporters/html.ts

```typescript
import { BaseReporter } from 'vitest/reporters';
import type { Reporter, TestCase, TestModule } from 'vitest/node';
import { writeFile } from 'node:fs/promises';
import { dirname, join } from 'pathe';
import { fileURLToPath } from 'node:url';

export class VibeHtmlReporter extends BaseReporter implements Reporter {
  private cases: Array<{ id: string; name: string; meta: any; result: any }> = [];

  onTestCaseResult(tc: TestCase) {
    this.cases.push({ id: tc.id, name: tc.fullName, meta: tc.meta?.(), result: tc.result?.() });
  }

  async onTestRunEnd(mods: readonly TestModule[]) {
    const html = this.renderHtml();
    const out = join(dirname(fileURLToPath(import.meta.url)), '../../vibe-report.html');
    await writeFile(out, html, 'utf8');
    this.log(`[vibe] HTML report: ${out}`);
  }

  private renderHtml() {
    const rows = this.cases
      .map(
        c => `<tr>
          <td>${escapeHtml(c.name)}</td>
          <td>${c.result?.state ?? 'unknown'}</td>
          <td>$${Number(c.meta?.metrics?.totalCostUsd ?? 0).toFixed(4)}</td>
          <td>${Number(c.meta?.metrics?.durationMs ?? 0).toFixed(0)} ms</td>
        </tr>`,
      )
      .join('\n');

    return `<!doctype html>
<html><head><meta charset="utf-8"><title>vibe report</title>
<style>
body{font-family:ui-sans-serif,system-ui,Arial}
table{border-collapse:collapse;width:100%}
td,th{border:1px solid #ddd;padding:8px}
th{background:#f3f4f6;text-align:left}
</style>
</head>
<body>
<h1>@dao/vibe-check</h1>
<table>
<thead><tr><th>Test</th><th>State</th><th>Cost</th><th>Duration</th></tr></thead>
<tbody>${rows}</tbody>
</table>
</body></html>`;
  }
}

function escapeHtml(s: any) {
  return String(s).replace(/[&<>"']/g, m => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m]!));
}
```

### reporters/index.ts

```typescript
export { VibeHtmlReporter } from '../src/reporters/html';
export { VibeCostReporter } from '../src/reporters/cost';
```

---

## Matrix

### src/matrix/defineTestSuite.ts

```typescript
import { describe } from 'vitest';
import { vibeTest } from '../test/vibeTest';

export function defineTestSuite<T extends Record<string, any[]>>(cfg: {
  matrix: T;
  name?: string;
  test: (combo: { [K in keyof T]: T[K][number] }) => void;
}) {
  const combos = cartesian(cfg.matrix);
  describe(cfg.name ?? 'matrix', () => {
    for (const params of combos) cfg.test(params as any);
  });
}

function cartesian<T extends Record<string, any[]>>(m: T): Array<{ [K in keyof T]: T[K][number] }> {
  const keys = Object.keys(m) as (keyof T)[];
  const out: any[] = [];
  const recur = (idx: number, acc: any) => {
    if (idx === keys.length) return out.push(acc);
    const k = keys[idx];
    for (const v of m[k]!) recur(idx + 1, { ...acc, [k]: v });
  };
  recur(0, {});
  return out as any;
}

// Re-export for convenience
export { vibeTest };
```

---

## Artifacts & metrics

### src/artifacts/ArtifactManager.ts

```typescript
import { ensureDir, writeFile } from 'fs-extra';
import { join } from 'pathe';
import type { StructuredRunData } from '../types';

export class ArtifactManager {
  constructor(private baseDir = '.vibe-artifacts') {}

  async saveText(testId: string, filename: string, content: string) {
    const dir = join(this.baseDir, sanitize(testId));
    await ensureDir(dir);
    await writeFile(join(dir, filename), content, 'utf8');
    return join(dir, filename);
  }

  async flushForTest(testId: string, data: StructuredRunData) {
    const dir = join(this.baseDir, sanitize(testId));
    await ensureDir(dir);
    await writeFile(join(dir, 'run.json'), JSON.stringify(data, null, 2), 'utf8');
  }

  async flush() {
    // no-op for now; keep for future buffered writes
  }
}

function sanitize(s: string) {
  return s.replace(/[^\w.-]/g, '_');
}
```

### src/metrics/MetricsTracker.ts

```typescript
import type { RunMetrics } from '../types';

export class MetricsTracker {
  totals: RunMetrics = {};

  record(m: RunMetrics) {
    if (m.totalTokens != null) this.totals.totalTokens = (this.totals.totalTokens ?? 0) + m.totalTokens;
    if (m.totalCostUsd != null) this.totals.totalCostUsd = (this.totals.totalCostUsd ?? 0) + m.totalCostUsd;
    if (m.durationMs != null) this.totals.durationMs = (this.totals.durationMs ?? 0) + m.durationMs;
  }
}
```

---

## Utils

### src/utils/dataQuery.ts

```typescript
import type { RunResult } from '../types';

export function findMessages(result: RunResult, rx: RegExp) {
  return (result.messages ?? []).filter(m => typeof m.content === 'string' && rx.test(m.content));
}

export function getToolUsageCount(result: RunResult, name: string) {
  return (result.toolCalls ?? []).filter(t => t.name === name).length;
}

export function completedTodos(result: RunResult) {
  return (result.todos ?? []).filter(t => t.status === 'completed');
}
```

### src/utils/tempfs.ts

```typescript
import { mkdtemp, rm } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

export async function createTempWorkspace(opts: { prefix: string }) {
  const dir = await mkdtemp(join(tmpdir(), `${opts.prefix}-`));
  return {
    dir,
    cleanup: async () => rm(dir, { recursive: true, force: true }),
  };
}
```

### src/utils/time.ts

```typescript
export const nowMs = () => Date.now();

export async function withTimeout<T>(p: Promise<T>, ms: number, msg = 'Timeout'): Promise<T> {
  let to: NodeJS.Timeout;
  const timeout = new Promise<never>((_, reject) => (to = setTimeout(() => reject(new Error(msg)), ms)));
  try {
    return await Promise.race([p, timeout]);
  } finally {
    clearTimeout(to!);
  }
}
```

### src/utils/git.ts

```typescript
// Skeleton for git worktree helpers. Implement as needed.
export async function prepareWorktree(_src: string, _dest: string) {
  // TODO: spawn git worktree add --detach ...
}

export async function cleanWorktree(_dest: string) {
  // TODO: remove worktree
}
```

---

## Example

### examples/basic.test.ts

```typescript
import { vibeTest } from '../src';

vibeTest('refactor stays under budget and completes todos', async ({ runAgent, judge, task, expect }) => {
  task.meta.maxCost = 3.5;

  const result = await runAgent({
    prompt: '/refactor src/index.ts',
    allowedTools: ['Edit', 'Bash'],
    maxTurns: 8,
  });

  expect(result).toStayUnderCost(task.meta.maxCost!);
  expect(result).toCompleteAllTodos();

  expect(result).toMatchSnapshot({
    metrics: { totalCostUsd: expect.any(Number), durationMs: expect.any(Number) },
    todos: expect.any(Array),
  });

  await judge(result, { rubric: { criteria: [{ id: 'q', description: 'quality', weight: 1 }], passingScore: 0.7, evaluationMethod: 'hybrid' }, throwOnFail: true });
});
```

---

## Notes

- The runner uses a mock SDK (`sdk-types.ts`) so the skeleton compiles. Replace `createSDKClient()` with the real Claude Agent SDK integration and map events accordingly.
- Reporters, matchers, and judge are minimal on purpose; fill in behavior as needed.
