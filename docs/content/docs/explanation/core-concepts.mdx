---
title: Core Concepts
description: Understanding key concepts in Vibe Check - agents, prompts, results, and evaluation
sidebar:
  order: 1
---

This page explains the core concepts and mental models that power Vibe Check.

## The Big Picture

Vibe Check is built around a simple flow:

```
Prompt ‚Üí Agent ‚Üí Execution ‚Üí Results ‚Üí Evaluation
```

Let's break down each piece.

---

## Prompts

**A prompt is what you ask the agent to do.**

```typescript
import { prompt } from '@dao/vibe-check';

// Simple text prompt
const p1 = prompt('/analyze codebase');

// Prompt with command and attachments
const p2 = prompt({
  text: 'Analyze these files for security issues',
  command: '/analyze',
  attachments: ['src/auth/*.ts']
});
```

**Key insight:** Prompts are async iterables, compatible with Claude's streaming API.

---

## Agents

**An agent is a configured execution environment.**

```typescript
import { defineAgent } from '@dao/vibe-check';

const securityReviewer = defineAgent({
  name: 'security-reviewer',
  model: 'claude-sonnet-4',
  tools: ['Read', 'Grep'],  // Read-only tools
  systemPrompt: {
    preset: 'security-auditor'
  }
});
```

**Key insight:** Agents separate **configuration** (model, tools, prompts) from **execution** (runAgent).

**Agent spec includes:**
- Model configuration (`model`, `maxTurns`, `timeouts`)
- Tool access control (`tools`, `mcpServers`)
- Project source (`source` - temp/local/git with isolation)
- System prompts (`systemPrompt` - presets or custom)
- Custom commands (`commands` - slash commands)

---

## Results

**Results capture everything that happened during execution.**

```typescript
const result = await runAgent({
  agent: securityReviewer,
  prompt: '/audit src/auth/'
});

// Auto-captured context
result.metrics    // Tokens, cost, duration, counts
result.files      // Changed files with lazy content loading
result.tools      // Tool calls with inputs/outputs
result.todos      // Todo list status
result.git        // Git state before/after
result.timeline   // Unified event timeline
result.messages   // Conversation messages
```

**Key insight:** Execution context is **automatically captured** via Claude Code hooks. You never manually manage artifacts.

### Auto-Capture System

During agent execution, Vibe Check:

1. **Writes hook events to temp files** (non-blocking, fast)
2. **Processes files after run** (correlate PreToolUse + PostToolUse, extract data)
3. **Stores in RunBundle** (disk-based, canonical source)
4. **Exposes via RunResult** (lazy accessors, memory-efficient)

**Why this matters:**
- üìä **Rich reporting** - HTML reports with transcripts, timelines, diffs
- üîç **Deep assertions** - Test file changes, tool usage, todos, costs
- üîó **Pipeline context** - Pass results between workflow stages

---

## Matchers

**Matchers are quality assertions for agent results.**

```typescript
// File matchers
expect(result).toHaveChangedFiles(['src/auth/login.ts']);
expect(result).toHaveNoDeletedFiles();

// Tool matchers
expect(result).toHaveUsedTool('Grep', { min: 1 });
expect(result).toUseOnlyTools(['Read', 'Grep']);

// Quality matchers
expect(result).toCompleteAllTodos();
expect(result).toHaveNoErrorsInLogs();

// Cost matchers
expect(result).toStayUnderCost(2.00);
```

**Key insight:** Matchers access auto-captured context without you manually extracting data.

---

## Judges

**Judges are LLM-based evaluators for subjective quality.**

```typescript
import { judge } from '@dao/vibe-check';

const rubric = {
  criteria: {
    correctness: {
      weight: 0.5,
      description: 'Code changes fix the reported bugs'
    },
    style: {
      weight: 0.3,
      description: 'Code follows project style guide'
    }
  }
};

const judgeResult = await judge(result, {
  rubric,
  throwOnFail: true
});

// Or as a matcher
expect(result).toPassRubric(rubric);
```

**Key insight:** Judges let you evaluate subjective quality (code style, explanation clarity) that matchers can't capture.

---

## vibeTest vs vibeWorkflow

Vibe Check provides **two APIs** tailored to different use cases:

### vibeTest - Evaluation & Testing

```typescript
vibeTest('benchmark sonnet', async ({ runAgent, expect, judge }) => {
  const result = await runAgent({
    agent: defineAgent({ model: 'claude-sonnet-4' }),
    prompt: '/refactor src/'
  });

  expect(result).toStayUnderCost(3.00);
  expect(result).toCompleteAllTodos();
  await judge(result, { rubric });
});
```

**Use when:**
- Benchmarking models/prompts/tools
- Enforcing quality gates
- Matrix testing configurations
- Writing tests with assertions

### vibeWorkflow - Automation & Pipelines

```typescript
vibeWorkflow('deploy pipeline', async (wf) => {
  const build = await wf.stage('build', {
    agent: builder,
    prompt: '/build'
  });

  const test = await wf.stage('test', {
    agent: tester,
    prompt: '/test',
    context: build
  });

  await wf.stage('deploy', {
    agent: deployer,
    prompt: '/deploy',
    context: test
  });
});
```

**Use when:**
- Multi-stage pipelines
- Agent orchestration
- Production automation
- Iterative loops (`wf.until()`)

**Key difference:** vibeWorkflow accumulates context across stages (files, tools, timeline), while vibeTest focuses on single-run evaluation.

---

## Isolation & Sources

**Agents can run in isolated git worktrees to avoid conflicts.**

```typescript
defineAgent({
  source: {
    type: 'git',
    url: 'https://github.com/foo/bar',
    branch: 'main',
    isolated: true  // Creates ephemeral worktree
  }
})
```

**Source types:**
- `temp` - Ephemeral temp directory (default)
- `local` - Existing local directory (no isolation)
- `git` - Clone or worktree from git repo (optional isolation)

**Why isolation?**
- ‚úÖ **Parallel execution** - Run multiple agents on same repo simultaneously
- ‚úÖ **No conflicts** - Each agent has its own workspace
- ‚úÖ **Clean state** - Every run starts fresh
- ‚úÖ **Safety** - Experiments don't affect main repo

---

## Reporting

Vibe Check generates **two types of reports**:

### 1. Terminal Reporter
- Cost/token aggregation across tests
- Summary at end of run
- Real-time progress updates

### 2. HTML Reporter
- Conversation transcripts
- Tool call timelines
- File diff viewer
- TODO status tracking
- Cost/token breakdowns
- Artifact links

**Key insight:** Reports read from **RunBundle** on disk, not from memory. This scales to large file changes without IPC overhead.

---

## Next Steps

Now that you understand the concepts:

- **Try it:** [First Automation](/getting-started/first-automation/) tutorial
- **Go deeper:** [Architecture Overview](/explanation/architecture/) explains internal design
- **Build something:** [Guides](/guides/) for practical how-tos
- **Reference:** [API docs](/api/) for complete type signatures

---

[‚Üê Back to Explanation](../)
