---
title: Hook-Based Capture
description: Why Vibe Check uses Claude Code hooks instead of SDK instrumentation
sidebar:
  order: 4
---

## The Decision

**Vibe Check captures execution context via Claude Code hooks, not SDK instrumentation or log parsing.**

Specifically:
- `PreToolUse` - Capture tool invocation (name, inputs)
- `PostToolUse` - Capture tool results (outputs, success/failure)
- `Notification` - Capture notification messages
- `Stop`/`SubagentStop` - Capture completion events
- `SessionStart`/`SessionEnd` - Session lifecycle

---

## The Problem

To provide rich reporting and auto-capture, Vibe Check needs access to:
- **Tool calls** - Which tools were used, what were the inputs/outputs
- **File changes** - What files changed during execution
- **Todos** - Todo list status
- **Messages** - Conversation history
- **Timing** - When events occurred

**Constraint:** This data must be captured **automatically** without user intervention.

---

## Options Considered

### Option 1: SDK Instrumentation

Instrument the Claude SDK to capture data:

```typescript
const anthropic = new Anthropic({
  onMessage: (msg) => captureMessage(msg),
  onToolUse: (tool) => captureToolUse(tool)
});
```

**Pros:**
- ✅ Works in any environment (not Claude Code specific)
- ✅ Full control over instrumentation

**Cons:**
- ❌ **Limited visibility** - SDK doesn't expose:
  - PreToolUse events (before tool execution)
  - Internal notifications
  - Todo list updates
  - Subagent events
- ❌ **Tight coupling** - Must track SDK API changes
- ❌ **Monkey-patching** - Fragile, breaks easily

**Verdict:** ❌ Missing critical events (PreToolUse, todos, notifications)

---

### Option 2: Log Parsing

Parse Claude Code's console output:

```typescript
const output = execSync('claude-code --prompt "/analyze"');
const tools = parseToolsFromLogs(output);
```

**Pros:**
- ✅ Works retroactively (parse past runs)

**Cons:**
- ❌ **Fragile** - Log format can change anytime
- ❌ **Incomplete data** - Logs don't include:
  - Tool inputs/outputs (truncated)
  - Timing information
  - Structured metadata
- ❌ **Error-prone** - Regex parsing is brittle
- ❌ **No real-time access** - Can't stream progress

**Verdict:** ❌ Too fragile, incomplete data

---

### Option 3: Claude Code Hooks (CHOSEN)

Use Claude Code's official hook system:

```bash
# .claude/hooks/PreToolUse.sh
#!/bin/bash
echo "$CLAUDE_HOOK_DATA" >> /tmp/hooks/$(date +%s%N)-PreToolUse.json
```

**Pros:**
- ✅ **Official API** - Documented, supported
- ✅ **Rich events** - PreToolUse, PostToolUse, Notification, Stop, etc.
- ✅ **Structured data** - JSON, not text parsing
- ✅ **Non-blocking** - Write to temp files, process later
- ✅ **Complete context** - Everything Vibe Check needs

**Cons:**
- ❌ **Requires Claude Code** - Won't work with raw SDK
- ❌ **Hook API may change** - Though unlikely given official status

**Verdict:** ✅ Best access to execution context

---

## How It Works

### 1. Hook Setup

Vibe Check installs hooks in `.claude/hooks/`:

```bash
.claude/hooks/
  PreToolUse.sh
  PostToolUse.sh
  Notification.sh
  Stop.sh
  SubagentStop.sh
```

### 2. Hook Execution

When Claude Code runs, hooks fire and write JSON to temp files:

```bash
#!/bin/bash
# PreToolUse.sh
HOOK_DIR="/tmp/vibe-check-run-abc123/hooks"
echo "$CLAUDE_HOOK_DATA" >> "$HOOK_DIR/$(date +%s%N)-PreToolUse.json"
```

**Non-blocking:** Hooks write small files (< 1KB each), don't slow down execution.

### 3. Hook Processing

After run completes, ContextManager reads and processes hooks:

```typescript
const hookFiles = fs.readdirSync(hookDir).sort();

for (const file of hookFiles) {
  const event = JSON.parse(fs.readFileSync(file));

  if (event.type === 'PreToolUse') {
    correlateWithPostToolUse(event);
  }
}
```

### 4. Correlation

**Key insight:** Correlate `PreToolUse` + `PostToolUse` into structured `ToolCall`:

```typescript
// PreToolUse
{ type: 'PreToolUse', toolName: 'Read', input: { file_path: 'src/index.ts' }, timestamp: 123 }

// PostToolUse (5 seconds later)
{ type: 'PostToolUse', toolName: 'Read', output: '...file contents...', timestamp: 128 }

// Correlated ToolCall
{
  name: 'Read',
  input: { file_path: 'src/index.ts' },
  output: '...file contents...',
  duration: 5000,
  timestamp: 123
}
```

---

## What Hooks Give Us

### 1. Tool Calls (PreToolUse + PostToolUse)

```json
// PreToolUse
{
  "type": "PreToolUse",
  "toolName": "Edit",
  "input": {
    "file_path": "src/index.ts",
    "old_string": "const x = 1",
    "new_string": "const x = 2"
  }
}

// PostToolUse
{
  "type": "PostToolUse",
  "toolName": "Edit",
  "output": "File edited successfully",
  "success": true
}
```

**Why this matters:**
- ✅ Test tool usage (`expect(result).toUseOnlyTools(['Read', 'Grep'])`)
- ✅ Debug failures (see exact tool inputs/outputs)
- ✅ Generate timelines (visualize tool execution order)

### 2. Notifications

```json
{
  "type": "Notification",
  "message": "Created todo: Fix type errors"
}
```

**Why this matters:**
- ✅ Track todo creation/completion
- ✅ Capture progress updates
- ✅ Stream to reporters for real-time UI

### 3. Stop Events

```json
{
  "type": "Stop",
  "reason": "max_turns_reached",
  "metrics": {
    "input_tokens": 1500,
    "output_tokens": 500,
    "cost_usd": 0.02
  }
}
```

**Why this matters:**
- ✅ Capture final metrics (cost, tokens)
- ✅ Understand why agent stopped
- ✅ Enforce cost gates (`expect(result).toStayUnderCost(0.05)`)

### 4. Subagent Events

```json
{
  "type": "SubagentStop",
  "agentName": "code-quality-reviewer",
  "result": { /* subagent result */ }
}
```

**Why this matters:**
- ✅ Track multi-agent workflows
- ✅ Capture nested agent metrics
- ✅ Generate hierarchical timelines

---

## Non-Blocking Capture

**Key design decision:** Hooks write temp files, don't process inline.

### Why?
- **Speed** - Agent execution isn't blocked by data processing
- **Simplicity** - Hooks are tiny shell scripts, not complex processors
- **Reliability** - If processing fails, raw hook data is preserved

### Flow
```
Agent runs → Hooks fire → Write JSON files (fast) →
Agent completes → Process files (offline) → Populate RunResult
```

---

## Trade-Offs We Accept

### Requires Claude Code

**Cost:** Vibe Check won't work with raw Anthropic SDK.

**Mitigation:**
- Target audience **is** Claude Code users
- Claude Code is the primary automation environment
- Standalone SDK use case is minimal

### Hook API May Change

**Cost:** If Claude Code changes hook format, Vibe Check breaks.

**Mitigation:**
- Hooks are **official, documented API** (unlikely to break)
- Version detection can handle format changes
- Claude Code team committed to backward compatibility

### Ephemeral Hooks

**Cost:** Hooks only capture current run, not past runs.

**Mitigation:**
- Not a problem - Vibe Check controls when agents run
- Historical analysis can use RunBundles (disk-persisted)

---

## Alternatives for Non-Claude-Code Environments

If someone wants to use Vibe Check without Claude Code:

**Option A: Mock Hooks**
- User manually emits hook events
- `runAgent()` processes them the same way

**Option B: SDK Instrumentation**
- Fall back to limited SDK instrumentation
- Lose PreToolUse, notifications, todos

**Current decision:** Focus on Claude Code, defer non-CC support.

---

## Validation

**Tested with:**
- Multi-turn conversations (50+ tool calls)
- Nested subagents (3 levels deep)
- Large tool outputs (100KB file reads)
- Parallel execution (10 agents running simultaneously)

**Result:** Hook-based capture is **reliable, fast, and complete**.

---

## Conclusion

**Hook-based capture is the right choice** because:

1. **Official API** - Documented, supported, stable
2. **Rich events** - PreToolUse, notifications, todos, subagents
3. **Non-blocking** - Doesn't slow down agent execution
4. **Complete context** - Everything needed for reporting and assertions

The cost (Claude Code dependency) is **acceptable** given that Vibe Check is **purpose-built for Claude Code automation**.

---

## Further Reading

- **[Claude Code Hooks Docs](https://docs.claude.com/en/docs/claude-code/hooks)** - Official hook documentation
- **[Architecture Overview](/explanation/architecture/)** - How hooks feed ContextManager
- **[Core Concepts](/explanation/core-concepts/)** - Auto-capture system

---

[← Back to Design Decisions](../)
