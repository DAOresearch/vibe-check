---
title: Storage Strategy
description: Why Vibe Check uses hybrid disk bundles + thin metadata
sidebar:
  order: 3
---

## The Decision

**Vibe Check uses a hybrid storage strategy:**
- **RunBundle** (disk) - Canonical source of truth for execution data
- **task.meta** (memory) - Thin metadata + pointer to bundle
- **RunResult** (lazy) - Lazy accessors that load from disk on demand

---

## The Problem

After agent execution, Vibe Check needs to store:
- **File changes** - Before/after content (potentially 100+ files × 10KB each = 1MB+)
- **Tool calls** - Inputs/outputs (can be large)
- **Messages** - Conversation history
- **Timeline** - Event log
- **Git state** - Commit hashes, diffs

**Constraint:** This data must be accessible to:
1. **Test code** - For assertions (`expect(result).toHaveChangedFiles(...)`)
2. **Reporters** - For HTML reports (transcripts, diffs, timelines)

---

## Options Considered

### Option 1: All-In-Memory (via task.meta)

Store everything in Vitest's `task.meta` object:

```typescript
task.meta.runContext = {
  files: { /* all file contents */ },
  tools: { /* all tool I/O */ },
  messages: { /* full conversation */ }
};
```

**Pros:**
- ✅ Simple implementation
- ✅ Fast access (no disk I/O)
- ✅ No cleanup needed

**Cons:**
- ❌ **Memory bloat** - 100+ file changes = 1MB+ per test
- ❌ **IPC overhead** - Vitest workers send `task.meta` over IPC to reporters
- ❌ **Serialization cost** - Large objects slow down worker communication
- ❌ **Doesn't scale** - Enterprise runs (100+ tests) = 100MB+ in memory

**Verdict:** ❌ Doesn't scale to large file changes

---

### Option 2: All-On-Disk

Write all data to disk, store only file paths in `task.meta`:

```typescript
task.meta.bundleDir = '/tmp/vibe-check-run-abc123';
// Reporters read files from disk
```

**Pros:**
- ✅ Scales to large data
- ✅ No memory bloat
- ✅ No IPC overhead

**Cons:**
- ❌ **Awkward test code** - Users must manually read files
  ```typescript
  // Bad DX
  const files = JSON.parse(fs.readFileSync(`${result.bundleDir}/files.json`));
  ```
- ❌ **Cleanup complexity** - Who deletes temp files? When?
- ❌ **Error-prone** - Easy to forget cleanup

**Verdict:** ❌ Poor DX for test code

---

### Option 3: Hybrid (CHOSEN)

**RunBundle (disk)** - Canonical source of truth
- Files: `/tmp/vibe-check-run-abc123/files/`
- Tools: `/tmp/vibe-check-run-abc123/tools.json`
- Timeline: `/tmp/vibe-check-run-abc123/timeline.json`
- Messages: `/tmp/vibe-check-run-abc123/messages.json`

**task.meta (memory)** - Thin metadata
```typescript
task.meta.runSummary = {
  bundleDir: '/tmp/vibe-check-run-abc123',
  metrics: { cost: 0.50, tokens: 1500 },
  fileSummary: { added: 2, modified: 3, deleted: 0 }
};
```

**RunResult (lazy accessors)** - User-facing API
```typescript
const result = await runAgent({ agent, prompt });

// Lazy loading
const file = result.files.get('src/index.ts');
const beforeText = await file?.before?.text();  // Reads from disk on demand
```

**Pros:**
- ✅ **Scales** - Large file changes stay on disk
- ✅ **Good DX** - Users get clean lazy API
- ✅ **No IPC overhead** - Reporters read from disk
- ✅ **Memory-efficient** - Only loaded when accessed

**Cons:**
- ❌ More complex implementation
- ❌ Disk I/O for large datasets

**Verdict:** ✅ Best balance of scalability and DX

---

## How It Works

### 1. During Execution

Hook events write to small temp files (non-blocking):

```
/tmp/vibe-check-run-abc123/
  hooks/
    0001-PreToolUse.json
    0002-PostToolUse.json
    0003-Notification.json
    ...
```

### 2. After Execution

ContextManager processes hooks and creates RunBundle:

```typescript
const bundle = await contextManager.processHooks(hookDir);

// Bundle structure
/tmp/vibe-check-run-abc123/
  files/
    src-index-ts.before.txt
    src-index-ts.after.txt
  tools.json          // Correlated tool calls
  timeline.json       // Unified timeline
  messages.json       // Conversation
  git.json           // Git state
  summary.json       // Metrics, counts
```

### 3. Expose to Test Code

```typescript
const result: RunResult = {
  metrics: bundle.summary.metrics,  // In-memory
  files: new LazyFileAccessor(bundle.files),  // Lazy
  tools: new LazyToolAccessor(bundle.tools),  // Lazy
  // ...
};
```

### 4. Reporters Read from Disk

```typescript
class VibeHtmlReporter extends BaseReporter {
  onTestCaseResult(test: TestCase) {
    const bundleDir = test.meta.runSummary?.bundleDir;
    const files = JSON.parse(fs.readFileSync(`${bundleDir}/files.json`));
    // Generate HTML with diffs
  }
}
```

---

## Memory Efficiency

**Example: 100 file changes, 10KB each**

| Strategy | Memory Usage | IPC Overhead |
|----------|--------------|--------------|
| All-in-memory | **1MB per test** | **1MB serialized** |
| Hybrid | **~10KB per test** | **~10KB serialized** |

**Savings:** 99% memory reduction, 99% IPC reduction

---

## Lazy Loading API

Users get a clean API without worrying about disk:

```typescript
const result = await runAgent({ agent, prompt });

// Files
const file = result.files.get('src/index.ts');
const beforeText = await file?.before?.text();  // Lazy load
const afterText = await file?.after?.text();

// Tools
const tools = await result.tools.all();  // Lazy load
const grepCalls = result.tools.filter('Grep');

// Timeline
const events = await result.timeline.all();  // Lazy load
```

**Implementation:**
```typescript
class LazyFileAccessor {
  constructor(private bundleDir: string) {}

  get(path: string): LazyFile | undefined {
    return new LazyFile(this.bundleDir, path);
  }
}

class LazyFile {
  before = {
    text: async () => {
      return fs.readFile(`${this.bundleDir}/files/${this.path}.before.txt`);
    }
  };
}
```

---

## Cleanup Strategy

**Current:** Manual cleanup (user's responsibility)

**Future options:**
1. **TTL-based** - Auto-delete bundles after 24 hours
2. **Size-based** - Keep last N bundles, delete oldest
3. **Manual** - `vibeCheck.clean()` command

**Decision deferred** until we see real-world usage patterns.

---

## Trade-Offs We Accept

### Disk I/O

**Cost:** Reading large datasets from disk adds latency.

**Mitigation:**
- Lazy loading (only read what's needed)
- In-memory caching (future optimization)
- SSDs make disk I/O fast enough

### Implementation Complexity

**Cost:** Hybrid approach is more complex than all-in-memory.

**Mitigation:**
- Complexity hidden behind clean API
- Well-tested ContextManager class
- Worth it for scalability gains

---

## Validation

**Benchmark:**
- 100 tests × 50 file changes each = 5,000 files
- All-in-memory: **50MB** in memory, **slow IPC**
- Hybrid: **1MB** in memory, **fast IPC**

**Result:** Hybrid scales to enterprise-level runs.

---

## Conclusion

**The hybrid strategy is the right choice** because:

1. **Scalability** - Handles 100+ file changes per run
2. **Memory efficiency** - 99% reduction vs all-in-memory
3. **Good DX** - Lazy accessors hide disk I/O
4. **No IPC bottleneck** - Reporters read from disk

The cost (implementation complexity) is **acceptable** for the **scalability gains**.

---

## Further Reading

- **[Architecture Overview](/explanation/architecture/)** - ContextManager and RunBundle
- **[Core Concepts](/explanation/core-concepts/)** - Auto-capture system
- **[API Reference](/api/types/)** - RunResult type definition

---

[← Back to Design Decisions](../)
