---
title: vibeWorkflow
description: Multi-stage pipeline orchestration for automation workflows
---

[API Reference](/api/) > vibeWorkflow

---

## Overview

`vibeWorkflow` is the automation-first API for building multi-stage agent pipelines, orchestrating workflows with loops and retries, and production automation. It provides cumulative context across stages and built-in loop helpers.

**Use cases:**
- Multi-stage agent pipelines
- Iterative workflows with loops
- Production automation
- Long-running workflows with retries
- Coordinating multiple agents

---

## Signature

```typescript
export function vibeWorkflow(
  name: string,
  fn: (ctx: WorkflowContext) => Promise<void>,
  options?: {
    timeout?: number;
    defaults?: { workspace?: string; model?: string }
  }
): void;
```

### Parameters

- **`name`** (`string`): Workflow name/description
- **`fn`** (`(ctx: WorkflowContext) => Promise<void>`): Workflow function with context
- **`options`** (optional): Workflow configuration
  - `timeout`: Timeout in milliseconds
  - `defaults`: Default workspace and model for all stages

---

## WorkflowContext

The workflow context provides stage execution and cumulative state:

```typescript
type WorkflowContext = {
  /** Run one stage, returns RunResult and accumulates into workflow */
  stage(name: string, opts: RunAgentOptions): Promise<RunResult>;

  /** Access cumulative state across stages */
  files: {
    allChanged(): FileChange[];
    byStage(stage?: string): FileChange[];
  };

  tools: {
    all(): Array<{ stage: string; call: ToolCall }>;
  };

  timeline: {
    events(): AsyncIterable<{ stage: string; evt: TimelineEvent }>
  };

  /** Loop helpers */
  until(
    predicate: (latest: RunResult) => boolean | Promise<boolean>,
    body: () => Promise<RunResult>,
    opts?: { maxIterations?: number }
  ): Promise<RunResult[]>;

  /** Default workspace & model overrides for this workflow */
  defaults: { workspace?: string; model?: string };
};
```

### Context Properties

#### `stage(name: string, opts: RunAgentOptions): Promise<RunResult>`

Execute one stage of the workflow. Returns a RunResult and automatically accumulates state into the workflow's cumulative context.

**Parameters:**
- `name`: Stage name (for logging and timeline)
- `opts`: RunAgent options (see [runAgent](/api/runAgent/))

**Returns:** Promise&lt;RunResult&gt;

#### `files`

Access file changes across all stages.

**Methods:**
- `allChanged()`: Get all changed files across all stages
- `byStage(stage?)`: Get files changed in specific stage (or current if omitted)

#### `tools`

Access tool calls across all stages.

**Methods:**
- `all()`: Get all tool calls with stage information

#### `timeline`

Get unified timeline of events across all stages.

**Methods:**
- `events()`: Async iterable of timeline events with stage labels

#### `until(predicate, body, opts?): Promise<RunResult[]>`

Loop helper for iterative workflows. Executes `body` until `predicate` returns true.

**Parameters:**
- `predicate`: Function that receives latest RunResult and returns boolean
- `body`: Function that returns a Promise&lt;RunResult&gt; (usually a stage)
- `opts`: Options
  - `maxIterations`: Maximum iterations (default: 10)

**Returns:** Array of all RunResults from iterations

#### `defaults`

Default workspace and model for the workflow. Can be overridden per stage.

---

## Examples

### Basic Multi-Stage Pipeline

```typescript
import { vibeWorkflow, defineAgent } from '@dao/vibe-check';

const analyzer = defineAgent({ name: 'analyzer' });
const fixer = defineAgent({ name: 'fixer' });
const tester = defineAgent({ name: 'tester' });

vibeWorkflow('refactor pipeline', async (wf) => {
  // Stage 1: Analyze
  const analysis = await wf.stage('analyze', {
    agent: analyzer,
    prompt: '/analyze codebase'
  });

  // Stage 2: Fix issues
  const fixes = await wf.stage('fix', {
    agent: fixer,
    prompt: '/fix issues from analysis',
    context: analysis
  });

  // Stage 3: Run tests
  const tests = await wf.stage('test', {
    agent: tester,
    prompt: '/run-tests'
  });

  // Access cumulative state
  console.log(`Total files changed: ${wf.files.allChanged().length}`);
  console.log(`Total tool calls: ${wf.tools.all().length}`);
});
```

### Iterative Workflow with Loop

```typescript
vibeWorkflow('iterative fix', async (wf) => {
  // Initial analysis
  const analyze = await wf.stage('analyze', {
    agent: analyzer,
    prompt: '/analyze'
  });

  // Loop until all todos are completed
  await wf.until(
    (latest) => latest.todos.every(t => t.status === 'completed'),
    async () => wf.stage('fix', {
      agent: fixer,
      prompt: '/fix remaining issues'
    }),
    { maxIterations: 3 }
  );

  // Cumulative assertions
  expect(wf.files.allChanged().length).toBeGreaterThan(0);
});
```

### Judge-Driven Workflow

```typescript
import { vibeWorkflow, judge } from '@dao/vibe-check';

const qualityRubric = {
  criteria: [
    { name: 'correctness', weight: 0.5 },
    { name: 'maintainability', weight: 0.5 }
  ]
};

vibeWorkflow('quality-driven refactor', async (wf) => {
  let passed = false;
  let iterations = 0;

  while (!passed && iterations++ < 3) {
    const result = await wf.stage(`attempt-${iterations}`, {
      agent: refactor,
      prompt: '/refactor with quality focus'
    });

    const evaluation = await judge(result, {
      rubric: qualityRubric,
      throwOnFail: false
    });

    passed = evaluation.passed;

    if (!passed && iterations < 3) {
      await wf.stage(`fix-${iterations}`, {
        agent: fixer,
        prompt: `/fix issues: ${evaluation.details}`
      });
    }
  }

  expect(passed).toBe(true);
});
```

### Workspace Defaults

```typescript
vibeWorkflow(
  'multi-repo workflow',
  async (wf) => {
    // Uses default workspace from options
    await wf.stage('update-main', {
      agent: updater,
      prompt: '/update-deps'
    });

    // Override workspace for specific stage
    await wf.stage('update-docs', {
      agent: docUpdater,
      prompt: '/update-docs',
      workspace: '/path/to/docs-repo'
    });

    // Back to default workspace
    await wf.stage('commit', {
      agent: committer,
      prompt: '/commit-changes'
    });
  },
  {
    defaults: { workspace: '/path/to/main-repo' }
  }
);
```

### Conditional Stages

```typescript
vibeWorkflow('conditional pipeline', async (wf) => {
  const analyze = await wf.stage('analyze', {
    agent: analyzer,
    prompt: '/analyze'
  });

  // Conditional execution based on analysis
  if (analyze.files.stats().total > 10) {
    await wf.stage('deep-review', {
      agent: deepReviewer,
      prompt: '/deep-review large change set'
    });
  }

  const build = await wf.stage('build', {
    agent: builder,
    prompt: '/build'
  });

  // Only deploy if build succeeded
  if (build.todos.every(t => t.status === 'completed')) {
    await wf.stage('deploy', {
      agent: deployer,
      prompt: '/deploy'
    });
  }
});
```

### Error Recovery

```typescript
vibeWorkflow('resilient pipeline', async (wf) => {
  let buildSuccess = false;
  let attempt = 0;

  // Retry build up to 3 times
  while (!buildSuccess && attempt++ < 3) {
    const build = await wf.stage(`build-attempt-${attempt}`, {
      agent: builder,
      prompt: '/build'
    });

    buildSuccess = !build.messages.some(m =>
      m.summary.includes('error')
    );

    if (!buildSuccess && attempt < 3) {
      // Run fixer before retry
      await wf.stage(`fix-attempt-${attempt}`, {
        agent: fixer,
        prompt: '/fix-build-errors'
      });
    }
  }

  expect(buildSuccess).toBe(true);
});
```

### Parallel Stages (Future)

```typescript
// Note: Current implementation is sequential
// Parallel execution planned for future release

vibeWorkflow('parallel tests', async (wf) => {
  const analyze = await wf.stage('analyze', {
    agent: analyzer,
    prompt: '/analyze'
  });

  // Future: parallel execution
  // const [unit, integration, e2e] = await Promise.all([
  //   wf.stage('unit-tests', { ... }),
  //   wf.stage('integration-tests', { ... }),
  //   wf.stage('e2e-tests', { ... })
  // ]);

  // Current: sequential
  const unit = await wf.stage('unit-tests', {
    agent: unitTester,
    prompt: '/run-unit-tests'
  });

  const integration = await wf.stage('integration-tests', {
    agent: integrationTester,
    prompt: '/run-integration-tests'
  });

  const e2e = await wf.stage('e2e-tests', {
    agent: e2eTester,
    prompt: '/run-e2e-tests'
  });
});
```

### Cumulative State Inspection

```typescript
vibeWorkflow('stateful pipeline', async (wf) => {
  await wf.stage('stage1', { agent: agent1, prompt: '/task1' });
  await wf.stage('stage2', { agent: agent2, prompt: '/task2' });
  await wf.stage('stage3', { agent: agent3, prompt: '/task3' });

  // Inspect cumulative state
  const allFiles = wf.files.allChanged();
  const stage2Files = wf.files.byStage('stage2');

  console.log('All changed files:', allFiles.map(f => f.path));
  console.log('Stage 2 files:', stage2Files.map(f => f.path));

  // Tool usage across workflow
  const toolsByStage = wf.tools.all().reduce((acc, { stage, call }) => {
    acc[stage] = acc[stage] || [];
    acc[stage].push(call.name);
    return acc;
  }, {} as Record<string, string[]>);

  console.log('Tools by stage:', toolsByStage);

  // Timeline
  for await (const { stage, evt } of wf.timeline.events()) {
    console.log(`[${stage}] ${evt.type}`);
  }
});
```

---

## Custom Timeouts

```typescript
vibeWorkflow(
  'long-running automation',
  async (wf) => {
    // workflow code
  },
  { timeout: 600000 } // 10 minutes
);
```

---

## Comparison with vibeTest

| Feature | vibeTest | vibeWorkflow |
|---------|----------|--------------|
| **Purpose** | Evaluation, benchmarking, quality gates | Automation, pipelines, production workflows |
| **Semantics** | Test pass/fail | Stage execution |
| **Assertions** | Built-in (`expect`) | Optional (import `expect`) |
| **Stages** | Single agent run | Multiple stages with cumulative state |
| **Loops** | Manual | Built-in `until()` helper |
| **Context** | Individual RunResult | Cumulative across stages |
| **Best for** | Comparing models, quality gates, benchmarks | Multi-step workflows, retries, automation |

---

## Related Documentation

- **[vibeTest](/api/vibeTest/)** - For evaluation and benchmarking
- **[runAgent](/api/runAgent/)** - Agent execution details
- **[RunResult](./types.md#runresult)** - Result interface
- **[Automation Guide](/guides/automation/pipelines/)** - Pipeline patterns
- **[Orchestration Guide](/guides/automation/orchestration/)** - Multi-agent coordination

---

[← Back to API Reference](/api/)
